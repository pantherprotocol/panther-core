// SPDX-License-Identifier: BUSL-1.1
// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar
// solhint-disable var-name-mixedcase
pragma solidity ^0.8.4;

import {FIELD_SIZE as SNARK_FIELD_SIZE} from "../crypto/SnarkConstants.sol";

// Content is autogenerated by `lib/triadMerkleZerosContractGenerator.ts`

/**
 * @dev The "triad binary tree" is a modified Merkle (full) binary tree with:
 * - every node, from the root upto the level preceding leaves, excluding
 * that level, has 2 child nodes (i.e. this subtree is a full binary tree);
 * - every node of the layer preceding leaves has 3 child nodes (3 leaves).
 * Example:
 * [4]                                       0
 *                                           |
 * [3]                        0--------------------------------1
 *                            |                                |
 * [2]                0---------------1                 2--------------3
 *                    |               |                 |              |
 * [1]            0-------1       2-------3        4-------5       6-------7
 *               /|\     /|\     /|\     /|\      /|\     /|\     /|\     /|\
 * [0] index:   0..2    3..5    6..8    9...11  12..14  15..17  18..20  21..24
 *
 *   leaf ID:   0..2    4..6    8..10   12..14  16..18  20..23  24..27  28..30
 *
 * - Number in [] is the "level index" that starts from 0 for the leaves level.
 * - Numbers in node/leaf positions are "node/leaf indices" which starts from 0
 *   for the leftmost node/leaf of every level.
 * - Numbers bellow leaves are IDs of leaves.
 *
 * Arithmetic operations with multiples of 2 (i.e. shifting) is "cheaper" than
 * operations with multiples of 3 (both on-chain and in zk-circuits).
 * Therefore, IDs of leaves (but NOT hashes of nodes) are calculated as if the
 * tree would have 4 (not 3) leaves in branches, with every 4th leaf skipped.
 * In other words, there are no leaves with IDs 3, 7, 11, 15, 19...
 */

// @notice The "triad binary tree" populated with zero leaf values
abstract contract TriadMerkleZeros {
    // @dev <% NOTE %>
    uint256 internal constant FIELD_SIZE = SNARK_FIELD_SIZE;

    // @dev Number of levels in a tree excluding the root level
    // (also defined in scripts/generateTriadMerkleZeroesContracts.sh)
    uint256 internal constant TREE_DEPTH = <% DEPTH %>;

    // Number of levels in a tree including both leaf and root levels
    uint256 internal constant TREE_LEVELS = TREE_DEPTH + 1;

    // Number of leaves in a branch with the root on the level 1
    uint256 internal constant TRIAD_SIZE = 3;

    // Number of leaves in the fully populated tree
    uint256 internal constant LEAVES_NUM = (2**(TREE_DEPTH - 1)) * TRIAD_SIZE;

    // @dev Leaf zero value (`keccak256("<% SEED %>")%FIELD_SIZE`)
    bytes32 internal constant ZERO_VALUE =
        bytes32(
            uint256(
                <% ZERO %>
            )
        );

    // Merkle root of a tree that contains zeros only
    bytes32 internal constant ZERO_ROOT =
        bytes32(
            uint256(
                <% ROOT %>
            )
        );

    function populateZeros(bytes32[TREE_DEPTH] memory zeros) internal pure {
<% ZEROS %>
    }
}
