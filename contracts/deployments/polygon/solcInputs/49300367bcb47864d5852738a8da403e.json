{
  "language": "Solidity",
  "sources": {
    "contracts/common/Claimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"./TransferHelper.sol\";\n\n/**\n * @title Claimable\n * @notice It withdraws accidentally sent tokens or ETH from this contract.\n */\nabstract contract Claimable {\n    /// @dev Withdraws ERC20 tokens from this contract\n    /// (take care of reentrancy attack risk mitigation)\n    function _claimErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        // withdraw ERC20\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    /// @dev Withdraws ERC20 tokens from this contract\n    /// (take care of reentrancy attack risk mitigation)\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function _claimEthOrErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (token == address(0)) {\n            // withdraw ETH\n            TransferHelper.safeTransferETH(to, amount);\n        } else {\n            // withdraw ERC20\n            TransferHelper.safeTransfer(token, to, amount);\n        }\n    }\n}\n"
    },
    "contracts/common/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title TransferHelper library\n/// @dev Helper methods for interacting with ERC20, ERC721, ERC1155 tokens and sending ETH\n/// Based on the Uniswap/solidity-lib/contracts/libraries/TransferHelper.sol\nlibrary TransferHelper {\n    /// @dev Throws if the deployed code of the `token` is empty.\n    // Low-level CALL to a non-existing contract returns `success` of 1 and empty `data`.\n    // It may be misinterpreted as a successful call to a deployed token contract.\n    // So, the code calling a token contract must insure the contract code exists.\n    modifier onlyDeployedToken(address token) {\n        uint256 codeSize;\n        // slither-disable-next-line assembly\n        assembly {\n            codeSize := extcodesize(token)\n        }\n        require(codeSize > 0, \"TransferHelper: zero codesize\");\n        _;\n    }\n\n    /// @dev Approve the `operator` to spend all of ERC720 tokens on behalf of `owner`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeSetApprovalForAll(\n        address token,\n        address operator,\n        bool approved\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('setApprovalForAll(address,bool)'));\n            abi.encodeWithSelector(0xa22cb465, operator, approved)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Get the ERC20 balance of `account`\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeBalanceOf(address token, address account)\n        internal\n        returns (uint256 balance)\n    {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256(bytes('balanceOf(address)')));\n            abi.encodeWithSelector(0x70a08231, account)\n        );\n        require(\n            // since `data` can't be empty, `onlyDeployedToken` unneeded\n            success && (data.length != 0),\n            \"TransferHelper: balanceOff call failed\"\n        );\n\n        balance = abi.decode(data, (uint256));\n    }\n\n    /// @dev Approve the `spender` to spend the `amount` of ERC20 token on behalf of `owner`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('approve(address,uint256)'));\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` ERC20 tokens from caller to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('transfer(address,uint256)'));\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` ERC20 tokens on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('transferFrom(address,address,uint256)'));\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer an ERC721 token with id of `tokenId` on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function erc721SafeTransferFrom(\n        address token,\n        uint256 tokenId,\n        address from,\n        address to\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('safeTransferFrom(address,address,uint256)'));\n            abi.encodeWithSelector(0x42842e0e, from, to, tokenId)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `amount` ERC1155 token with id of `tokenId` on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function erc1155SafeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory _data\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)'));\n            abi.encodeWithSelector(0xf242432a, from, to, tokenId, amount, _data)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` Ether from caller to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransferETH(address to, uint256 value) internal {\n        // slither-disable-next-line low-level-calls\n        (bool success, ) = to.call{ value: value }(new bytes(0));\n        require(success, \"TransferHelper: ETH transfer failed\");\n    }\n\n    function _requireSuccess(bool success, bytes memory res) private pure {\n        require(\n            success && (res.length == 0 || abi.decode(res, (bool))),\n            \"TransferHelper: token contract call failed\"\n        );\n    }\n}\n"
    },
    "contracts/staking/ZkpFaucet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../common/Claimable.sol\";\nimport \"../common/ImmutableOwnable.sol\";\n\n// When called `drink`, it sends tokens to the `_to`\n// As a prerequisite, it shall get enough tokens on the balance\ncontract ZkpFaucet is Claimable, ImmutableOwnable {\n    address public immutable token;\n    uint256 public cupSize;\n    uint256 public tokenPrice;\n    uint256 public maxAmountToPay;\n    uint256 public maxDrinkCount;\n\n    // @notice  store the whitelisted addresses who can drink\n    mapping(address => bool) public whitelistedAddresses;\n    // @notice store the number of times each user has drank\n    mapping(address => uint256) public drinkCount;\n\n    // @notice enabling/disabling check for whitelisted addresses\n    bool public restrictToWhitelisted;\n\n    event CupSizeUpdated(uint256 newCupSice);\n    event TokenPriceUpdated(uint256 newTokenPrice);\n    event MaxDrinkCountUpdated(uint256 newMaxDrinkCount);\n    event WhitelistRestrictUpdated(bool newIsRestricted);\n\n    constructor(\n        address _owner,\n        address _token,\n        uint256 _tokenPrice,\n        uint256 _maxAmountToPay,\n        uint256 _cupSize,\n        uint256 _maxDrinkCount\n    ) ImmutableOwnable(_owner) {\n        require(_cupSize > 0, \"invalid cup size\");\n        require(_token != address(0), \"invalid token address\");\n\n        token = _token;\n        tokenPrice = _tokenPrice;\n        cupSize = _cupSize;\n        maxAmountToPay = _maxAmountToPay;\n        maxDrinkCount = _maxDrinkCount;\n\n        emit TokenPriceUpdated(_tokenPrice);\n        emit CupSizeUpdated(_cupSize);\n        emit MaxDrinkCountUpdated(_maxDrinkCount);\n        emit WhitelistRestrictUpdated(false);\n    }\n\n    /**\n     * @notice if restrictToWhitelisted is true, then\n     * check if the sender is whitelisted\n     */\n    modifier onlyWhitelisted(address _address) {\n        require(\n            !restrictToWhitelisted || isWhitelisted(_address),\n            \"Not whitelisted\"\n        );\n        _;\n    }\n\n    /**\n     * @notice if maxDrinkCount is defined, then\n     * check if the sender is already received token\n     */\n    modifier checkDrinkCount(address _address) {\n        require(\n            maxDrinkCount == 0 || withinDrinkLimit(_address),\n            \"Reached maximum drink count\"\n        );\n        _;\n    }\n\n    /**\n     * @notice if token price is more than 0, then\n     * check the value\n     */\n    modifier validatePrice() {\n        require(msg.value <= maxAmountToPay, \"High value\");\n        require(msg.value >= tokenPrice, \"Low value\");\n        _;\n    }\n\n    /**\n     * @notice return true if the address is whitelisted, otherwise false\n     * @dev it helps when contract is restricted to whitelisted addresses\n     */\n    function isWhitelisted(address _account) public view returns (bool) {\n        return whitelistedAddresses[_account];\n    }\n\n    /**\n     * @notice return true if the user request counts are\n     * less than or equal to maxDrinkCount, otherwise returns false\n     * @dev it helps when contract is restricted to requests count.\n     */\n    function withinDrinkLimit(address _account) public view returns (bool) {\n        return drinkCount[_account] < maxDrinkCount;\n    }\n\n    /**\n     * @notice send tokens to `_to`\n     * @param _to the receiver addresss\n     * @dev if restrictToWhitelisted is true, then check if the\n     * sender is whitelisted.\n     * if the restrictToMaxReq is true, then check if the\n     * sender is already received token.\n     */\n    function drink(address _to)\n        external\n        payable\n        validatePrice\n        onlyWhitelisted(msg.sender)\n        checkDrinkCount(_to)\n    {\n        drinkCount[_to]++;\n\n        safeTransfer(token, _to, getCupSize(msg.value));\n    }\n\n    function getCupSize(uint256 _amountToPay) public view returns (uint256) {\n        return tokenPrice > 0 ? _amountToPay / tokenPrice : cupSize;\n    }\n\n    function safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        // solhint-disable avoid-low-level-calls\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(0xa9059cbb, _to, _value)\n        );\n        // solhint-enable avoid-low-level-calls\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeTransfer: transfer failed\"\n        );\n    }\n\n    // Owner functions\n    /**\n     * @notice update restrictToWhitelisted\n     */\n    function updateRestrictToWhitelisted(bool isRestricted) external onlyOwner {\n        restrictToWhitelisted = isRestricted;\n        emit WhitelistRestrictUpdated(isRestricted);\n    }\n\n    /**\n     * @notice Add multiple addresses to the whitelisted list\n     * @param _whitelistedAddresses array of addresses to be added\n     * @param _whitelisted array of boolen values to be mapped to the addresses\n     */\n    function whitelistBatch(\n        address[] calldata _whitelistedAddresses,\n        bool[] calldata _whitelisted\n    ) external onlyOwner {\n        for (uint256 i = 0; i < _whitelistedAddresses.length; ) {\n            whitelistedAddresses[_whitelistedAddresses[i]] = _whitelisted[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice update the amount that can be received by users\n     * @param _cupSize the amount that can be received by users\n     */\n    function updateCupSize(uint256 _cupSize) external onlyOwner {\n        require(_cupSize > 0, \"invalid size\");\n        cupSize = _cupSize;\n        emit CupSizeUpdated(_cupSize);\n    }\n\n    /**\n     * @notice update the token price.\n     * @param _tokenPrice the price of each token\n     */\n    function updateTokenPrice(uint256 _tokenPrice) external onlyOwner {\n        tokenPrice = _tokenPrice;\n        emit TokenPriceUpdated(_tokenPrice);\n    }\n\n    /**\n     * @notice update the token price.\n     * @param _maxDrinkCount the maximum number of times the\n     * drink function can be called\n     */\n    function updateMaxDrinkCount(uint256 _maxDrinkCount) external onlyOwner {\n        maxDrinkCount = _maxDrinkCount;\n        emit MaxDrinkCountUpdated(_maxDrinkCount);\n    }\n\n    /**\n     * @notice whithdraws native or erc20 token from the contract\n     * @param _claimedToken The token address to claim\n     * @param _to the receiver address\n     * @param _amount the token amount to be withdrawn\n     * @dev The token address can be zero address in case the\n     * native token is going to be withdrawn.\n     */\n    function withdraw(\n        address _claimedToken,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        require(_to != address(0), \"recipient cannot be 0\");\n        require(_amount > 0, \"amount cannot be 0\");\n\n        if (_claimedToken == address(0)) {\n            // solhint-disable avoid-low-level-calls\n            // slither-disable-next-line low-level-calls\n            (bool sent, ) = _to.call{ value: _amount }(\"\");\n            // solhint-enable avoid-low-level-calls\n            require(sent, \"Failed to send native\");\n        } else {\n            _claimErc20(_claimedToken, _to, _amount);\n        }\n    }\n}\n"
    },
    "contracts/common/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/common/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nabstract contract Utils {\n    // false positive\n    // slither-disable-next-line timestamp\n    function safe32(uint256 n) internal pure returns (uint32) {\n        require(n < 2**32, \"UNSAFE32\");\n        return uint32(n);\n    }\n\n    function safe96(uint256 n) internal pure returns (uint96) {\n        require(n < 2**96, \"UNSAFE96\");\n        return uint96(n);\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe128(uint256 n) internal pure returns (uint128) {\n        require(n < 2**128, \"UNSAFE128\");\n        return uint128(n);\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe160(uint256 n) internal pure returns (uint160) {\n        require(n < 2**160, \"UNSAFE160\");\n        return uint160(n);\n    }\n\n    function safe32TimeNow() internal view returns (uint32) {\n        return safe32(timeNow());\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe32BlockNow() internal view returns (uint32) {\n        return safe32(blockNow());\n    }\n\n    /// @dev Returns the current block timestamp (added to ease testing)\n    function timeNow() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /// @dev Returns the current block number (added to ease testing)\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function blockNow() internal view virtual returns (uint256) {\n        return block.number;\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function revertZeroAddress(address account) internal pure {\n        require(account != address(0), \"UNEXPECTED_ZERO_ADDRESS\");\n    }\n}\n"
    },
    "contracts/staking/interfaces/IRewardAdviser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IRewardAdviser {\n    struct Advice {\n        // advice on new \"shares\" (in the reward pool) to create\n        address createSharesFor;\n        uint96 sharesToCreate;\n        // advice on \"shares\" to redeem\n        address redeemSharesFrom;\n        uint96 sharesToRedeem;\n        // advice on address the reward against redeemed shares to send to\n        address sendRewardTo;\n    }\n\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        returns (Advice memory);\n}\n"
    },
    "contracts/common/NonReentrant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/**\n * @title NonReentrant\n * @notice It provides reentrancy guard.\n * The code borrowed from openzeppelin-contracts.\n * Unlike original, this version requires neither `constructor` no `init` call.\n */\nabstract contract NonReentrant {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _reentrancyStatus;\n\n    modifier nonReentrant() {\n        // Being called right after deployment, when _reentrancyStatus is 0 ,\n        // it does not revert (which is expected behaviour)\n        require(_reentrancyStatus != _ENTERED, \"claimErc20: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _reentrancyStatus = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyStatus = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/staking/interfaces/IErc20Approve.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @dev Interface to call ERC-20 `approve` function\ninterface IErc20Approve {\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    // Beware of risk: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/staking/interfaces/IErc20Min.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IErc20Min {\n    /// @dev ERC-20 `balanceOf`\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @dev ERC-20 `transfer`\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /// @dev ERC-20 `transferFrom`\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @dev EIP-2612 `permit`\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/staking/interfaces/IVotingPower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title IStaking\ninterface IVotingPower {\n    struct Snapshot {\n        uint32 beforeBlock;\n        uint96 ownPower;\n        uint96 delegatedPower;\n    }\n\n    /// @dev Voting power integrants\n    struct Power {\n        uint96 own; // voting power that remains after delegating to others\n        uint96 delegated; // voting power delegated by others\n    }\n\n    /// @notice Returns total voting power staked\n    /// @dev \"own\" and \"delegated\" voting power summed up\n    function totalVotingPower() external view returns (uint256);\n\n    /// @notice Returns total \"own\" and total \"delegated\" voting power separately\n    /// @dev Useful, if \"own\" and \"delegated\" voting power treated differently\n    function totalPower() external view returns (Power memory);\n\n    /// @notice Returns global snapshot for given block\n    /// @param blockNum - block number to get state at\n    /// @param hint - off-chain computed index of the required snapshot\n    function globalSnapshotAt(uint256 blockNum, uint256 hint)\n        external\n        view\n        returns (Snapshot memory);\n\n    /// @notice Returns snapshot on given block for given account\n    /// @param _account - account to get snapshot for\n    /// @param blockNum - block number to get state at\n    /// @param hint - off-chain computed index of the required snapshot\n    function snapshotAt(\n        address _account,\n        uint256 blockNum,\n        uint256 hint\n    ) external view returns (Snapshot memory);\n\n    /// @dev Returns block number of the latest global snapshot\n    function latestGlobalsSnapshotBlock() external view returns (uint256);\n\n    /// @dev Returns block number of the given account latest snapshot\n    function latestSnapshotBlock(address _account)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Returns number of global snapshots\n    function globalsSnapshotLength() external view returns (uint256);\n\n    /// @dev Returns number of snapshots for given account\n    function snapshotLength(address _account) external view returns (uint256);\n\n    /// @dev Returns global snapshot at given index\n    function globalsSnapshot(uint256 _index)\n        external\n        view\n        returns (Snapshot memory);\n\n    /// @dev Returns snapshot at given index for given account\n    function snapshot(address _account, uint256 _index)\n        external\n        view\n        returns (Snapshot memory);\n}\n"
    },
    "contracts/staking/interfaces/IStakingTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IStakingTypes {\n    // Stake type terms\n    struct Terms {\n        // if stakes of this kind allowed\n        bool isEnabled;\n        // if messages on stakes to be sent to the {RewardMaster}\n        bool isRewarded;\n        // limit on the minimum amount staked, no limit if zero\n        uint32 minAmountScaled;\n        // limit on the maximum amount staked, no limit if zero\n        uint32 maxAmountScaled;\n        // Stakes not accepted before this time, has no effect if zero\n        uint32 allowedSince;\n        // Stakes not accepted after this time, has no effect if zero\n        uint32 allowedTill;\n        // One (at least) of the following three params must be non-zero\n        // if non-zero, overrides both `exactLockPeriod` and `minLockPeriod`\n        uint32 lockedTill;\n        // ignored if non-zero `lockedTill` defined, overrides `minLockPeriod`\n        uint32 exactLockPeriod;\n        // has effect only if both `lockedTill` and `exactLockPeriod` are zero\n        uint32 minLockPeriod;\n    }\n\n    struct Stake {\n        // index in the `Stake[]` array of `stakes`\n        uint32 id;\n        // defines Terms\n        bytes4 stakeType;\n        // time this stake was created at\n        uint32 stakedAt;\n        // time this stake can be claimed at\n        uint32 lockedTill;\n        // time this stake was claimed at (unclaimed if 0)\n        uint32 claimedAt;\n        // amount of tokens on this stake (assumed to be less 1e27)\n        uint96 amount;\n        // address stake voting power is delegated to\n        address delegatee;\n    }\n}\n"
    },
    "contracts/staking/interfaces/IArptHistory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IArptHistory {\n    function getScArptAt(uint32 timestamp)\n        external\n        view\n        returns (uint256 scArpt);\n}\n"
    },
    "contracts/staking/interfaces/IStakeRegister.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"./IStakingTypes.sol\";\n\ninterface IStakeRegister {\n    function stakes(address _account, uint256 _stakeId)\n        external\n        view\n        returns (IStakingTypes.Stake memory);\n\n    function accountStakes(address _account)\n        external\n        view\n        returns (IStakingTypes.Stake[] memory);\n}\n"
    },
    "contracts/staking/mocks/MockStakingMsgProcessor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"../actions/StakingMsgProcessor.sol\";\nimport \"../interfaces/IStakingTypes.sol\";\n\ncontract MockStakingMsgProcessor is StakingMsgProcessor {\n    function internalEncodeStakeActionType(bytes4 stakeType)\n        external\n        pure\n        returns (bytes4)\n    {\n        return _encodeStakeActionType(stakeType);\n    }\n\n    function internalEncodeUnstakeActionType(bytes4 stakeType)\n        external\n        pure\n        returns (bytes4)\n    {\n        return _encodeUnstakeActionType(stakeType);\n    }\n\n    function internalPackStakingActionMsg(\n        address staker,\n        IStakingTypes.Stake memory stake,\n        bytes calldata data\n    ) external pure returns (bytes memory) {\n        return _packStakingActionMsg(staker, stake, data);\n    }\n\n    function internalUnpackStakingActionMsg(bytes memory message)\n        external\n        pure\n        returns (\n            address staker,\n            uint96 amount,\n            uint32 id,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            uint32 claimedAt,\n            bytes memory data\n        )\n    {\n        return _unpackStakingActionMsg(message);\n    }\n}\n"
    },
    "contracts/staking/actions/StakingMsgProcessor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IStakingTypes.sol\";\n\nabstract contract StakingMsgProcessor {\n    bytes4 internal constant STAKE_ACTION = bytes4(keccak256(\"stake\"));\n    bytes4 internal constant UNSTAKE_ACTION = bytes4(keccak256(\"unstake\"));\n\n    function _encodeStakeActionType(bytes4 stakeType)\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(abi.encodePacked(STAKE_ACTION, stakeType)));\n    }\n\n    function _encodeUnstakeActionType(bytes4 stakeType)\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(abi.encodePacked(UNSTAKE_ACTION, stakeType)));\n    }\n\n    function _packStakingActionMsg(\n        address staker,\n        IStakingTypes.Stake memory stake,\n        bytes calldata data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                staker, // address\n                stake.amount, // uint96\n                stake.id, // uint32\n                stake.stakedAt, // uint32\n                stake.lockedTill, // uint32\n                stake.claimedAt, // uint32\n                data // bytes\n            );\n    }\n\n    // For efficiency we use \"packed\" (rather than \"ABI\") encoding.\n    // It results in shorter data, but requires custom unpack function.\n    function _unpackStakingActionMsg(bytes memory message)\n        internal\n        pure\n        returns (\n            address staker,\n            uint96 amount,\n            uint32 id,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            uint32 claimedAt,\n            bytes memory data\n        )\n    {\n        // staker, amount, id and 3 timestamps occupy exactly 48 bytes\n        // (`data` may be of zero length)\n        require(message.length >= 48, \"SMP: unexpected msg length\");\n\n        uint256 stakerAndAmount;\n        uint256 idAndStamps;\n        // solhint-disable no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            // the 1st word (32 bytes) contains the `message.length`\n            // we need the (entire) 2nd word ..\n            stakerAndAmount := mload(add(message, 0x20))\n            // .. and (16 bytes of) the 3rd word\n            idAndStamps := mload(add(message, 0x40))\n        }\n        // solhint-enable no-inline-assembly\n\n        staker = address(uint160(stakerAndAmount >> 96));\n        amount = uint96(stakerAndAmount & 0xFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        id = uint32((idAndStamps >> 224) & 0xFFFFFFFF);\n        stakedAt = uint32((idAndStamps >> 192) & 0xFFFFFFFF);\n        lockedTill = uint32((idAndStamps >> 160) & 0xFFFFFFFF);\n        claimedAt = uint32((idAndStamps >> 128) & 0xFFFFFFFF);\n\n        uint256 dataLength = message.length - 48;\n        data = new bytes(dataLength);\n        for (uint256 i = 0; i < dataLength; i++) {\n            data[i] = message[i + 48];\n        }\n    }\n}\n"
    },
    "contracts/staking/AdvancedStakeRewardController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./actions/AdvancedStakingDataDecoder.sol\";\nimport \"./actions/Constants.sol\";\nimport \"./actions/StakingMsgProcessor.sol\";\nimport \"./interfaces/IERC721Receiver.sol\";\nimport \"./interfaces/INftGrantor.sol\";\nimport \"./interfaces/IPantherPoolV0.sol\";\nimport \"./interfaces/IRewardAdviser.sol\";\nimport \"../common/Claimable.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/NonReentrant.sol\";\nimport \"../common/Utils.sol\";\nimport \"../common/TransferHelper.sol\";\n\n/**\n * @title AdvancedStakeRewardController\n * @notice It generates UTXOs in the MASP as rewards to stakers for the \"Advanced Staking\"\n * @dev This contract is supposed to run on the Polygon. Unless otherwise mentioned, other smart\n * contracts are supposed to run on the Polygon also.\n * As the \"Reward Adviser\" on the \"advanced\" stakes, every time a new stake is being created, it\n * receives the `getRewardAdvice` call from the `RewardMaster` contract with the `STAKE` action\n * type and the stake data (the `message`) being the call parameters.\n * On the `getRewardAdvice` call received, this contract:\n * - computes the amounts of the $ZKP reward and the optional NFT reward\n * - if the `NFT_TOKEN` is non-zero address, it calls `grantOneToken` on the NFT_TOKEN, and gets\n * the `tokenId` of the minted NFT token\n * - calls `generateDeposits` of the PantherPoolV0, providing amounts/parameters of $ZKP, and\n *   optional NFT as \"deposits\", as well as \"spending pubKeys\" and \"secrets\" (explained below)\n * - returns the \"zero reward advice\" (with zero `sharesToCreate`) to the RewardMaster.\n *\n * On the \"zero\" advice, the RewardMaster skips creating \"treasure shares\" for the staker. This way\n * rewarding gets orchestrated by this contract rather than the RewardMaster.\n *\n * Being called `generateDeposits`, the PantherPoolV0:\n * - requests the `Vault` to take (`transferFrom`) the $ZKP and NFT tokens from this contract\n * - generates \"UTXOs\" with the \"spending pubKeys\" and \"secrets\" provided (see bellow).\n *\n * Creating a new stake (i.e. calling the `stake`), the staker generates and provides the \"pubKeys\"\n * and \"secrets\" to the Staking. Both the Staking on the mainnet and the Staking on the Polygon\n * encodes them into the STAKE message and passes to the RewardMaster, which passes the message to\n * this contract with the `getRewardAdvice` call. So this contracts get pubKeys and secrets needed\n * for the `generateDeposits`.\n * For stakes on the Polygon, when all contracts (i.e. Staking, RewardMaster and this contract) run\n * on the same network, the RewardMaster on the Polygon calls this contract directly.\n * For stakes made on the mainnet, where the Staking and the RewardMaster run, but this contract is\n * on the Polygon, the RewardMaster on the mainnet sends the STAKE message to the RewardMaster on\n * the Polygon via the PoS bridge and mediator contracts. The RewardMaster on the Polygon handles a\n * bridged STAKE message (calling the `getRewardAdvice`) as if the message had been sent by the\n * Staking on the Polygon.\n *\n * As a prerequisite:\n * - this contract shall:\n * -- be authorized as the \"RewardAdviser\" with the RewardMaster on the Polygon for advanced stakes\n * -- be authorized as \"Minter\" (aka \"grantor\") with the NFT_TOKEN contract\n * -- hold enough $ZKP to reward stakers\n * - the Vault contract shall be approved to transfer $ZKPs and the NFT tokens from this contract\n * - the $ZKP and the NFT tokens shall be registered as zAssets on the PantherPoolV0.\n */\ncontract AdvancedStakeRewardController is\n    ImmutableOwnable,\n    NonReentrant,\n    StakingMsgProcessor,\n    AdvancedStakingDataDecoder,\n    Utils,\n    Claimable,\n    IERC721Receiver,\n    IRewardAdviser\n{\n    using TransferHelper for address;\n\n    /// @dev Total amount of $ZKP and NFTs (ever) rewarded and staked\n    struct Totals {\n        uint96 zkpRewards;\n        uint24 nftRewards;\n        // Accumulated amount of $ZKP (ever) staked, scaled (divided) by 1e15\n        uint40 scZkpStaked;\n    }\n\n    /// @dev Maximum amounts of $ZKPs and NFTs which may be rewarded\n    struct Limits {\n        uint96 zkpRewards;\n        uint24 nftRewards;\n    }\n\n    /// @dev Reward Timestamps and APYs\n    struct RewardParams {\n        /// @param (UNIX) Time when $ZKP rewards start to accrue\n        uint32 startTime;\n        /// @param (UNIX) Time when $ZKP rewards accruals end\n        uint32 endTime;\n        /// @param $ZKP reward APY at startTime (APY declines from this value)\n        uint8 startZkpApy;\n        /// @param $ZKP reward APY at endTime (APY declines to this value)\n        uint8 endZkpApy;\n    }\n\n    // solhint-disable var-name-mixedcase\n    // These three constants used to align with IPantherPool::generateDeposits API\n    uint256 private constant ZERO_AMOUNT = 0;\n    uint256 private constant ZERO_TOKEN_ID = 0;\n    address private constant ZERO_TOKEN = address(0);\n\n    /// @notice RewardMaster contract instance\n    address public immutable REWARD_MASTER;\n    /// @notice PantherPoolV0 contract instance\n    address public immutable PANTHER_POOL;\n\n    // Address of the $ZKP token contract\n    address private immutable ZKP_TOKEN;\n    // Address of the NFT token contract\n    address private immutable NFT_TOKEN;\n\n    /// @notice Block when this contract is deployed\n    uint256 public immutable START_BLOCK;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice Amounts of $ZKP and NFT allocated for rewards\n    Limits public limits;\n\n    /// @notice Total amounts of $ZKP and NFT rewarded so far\n    Totals public totals;\n\n    /// @notice Reward parameters (start and end point for time and APY)\n    RewardParams public rewardParams;\n\n    /// @dev Emitted when new amounts are allocated to reward stakers\n    event RewardLimitUpdated(Limits newLimits);\n\n    /// @dev Emitted when rewarding params updated\n    event RewardParamsUpdated(RewardParams newRewardParams);\n\n    /// @dev Emitted when the reward for a stake is generated\n    event RewardGenerated(\n        address indexed staker,\n        uint256 firstLeafId,\n        uint256 zkp,\n        uint256 nft\n    );\n\n    constructor(\n        address _owner,\n        address rewardMaster,\n        address pantherPool,\n        address zkpToken,\n        address nftToken\n    ) ImmutableOwnable(_owner) {\n        require(\n            // nftToken may be zero address\n            rewardMaster != address(0) &&\n                pantherPool != address(0) &&\n                zkpToken != address(0),\n            \"ARC:E1\"\n        );\n\n        REWARD_MASTER = rewardMaster;\n        PANTHER_POOL = pantherPool;\n\n        ZKP_TOKEN = zkpToken;\n        NFT_TOKEN = nftToken;\n\n        START_BLOCK = block.number;\n    }\n\n    /// @dev To be called by the {RewardMaster} contract on \"advanced\" `STAKE` and `UNSTAKE` actions.\n    /// The caller is trusted to never call w/ the STAKE acton:\n    /// - twice for the same stake\n    /// - after the rewarded period has ended\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        override\n        returns (Advice memory)\n    {\n        require(msg.sender == REWARD_MASTER, \"ARC: unauthorized\");\n\n        if (action == ADVANCED_STAKE) {\n            _generateRewards(message);\n        } else {\n            require(action == ADVANCED_UNSTAKE, \"ARC: unsupported action\");\n        }\n\n        // Return \"zero\" advice\n        return\n            Advice(\n                address(0), // createSharesFor\n                0, // sharesToCreate\n                address(0), // redeemSharesFrom\n                0, // sharesToRedeem\n                address(0) // sendRewardTo\n            );\n    }\n\n    /// @notice Return the APY for the $ZKP reward at a given time\n    function getZkpApyAt(uint256 time) external view returns (uint256) {\n        RewardParams memory _rewardParams = rewardParams;\n        if (time < _rewardParams.startTime || time > _rewardParams.endTime)\n            return 0;\n\n        return _getZkpApyWithinRewardedPeriod(_rewardParams, time);\n    }\n\n    function updateRewardParams(RewardParams memory _newParams)\n        external\n        onlyOwner\n    {\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(\n            _newParams.startTime != 0 &&\n                _newParams.endTime > _newParams.startTime &&\n                _newParams.endTime > timeNow(),\n            \"ARC: invalid time\"\n        );\n        require(\n            _newParams.startZkpApy >= _newParams.endZkpApy,\n            \"ARC: invalid APY\"\n        );\n\n        rewardParams = _newParams;\n        emit RewardParamsUpdated(_newParams);\n    }\n\n    /// @notice Allocate NFT rewards and approve the Vault to transfer them\n    /// @dev Only owner may call it.\n    function setNftRewardLimit(uint256 _desiredNftRewardsLimit)\n        external\n        onlyOwner\n    {\n        if (NFT_TOKEN == address(0)) return;\n\n        Limits memory _limits = limits;\n\n        require(\n            _desiredNftRewardsLimit > totals.nftRewards,\n            \"ARC: low nft rewards limit\"\n        );\n\n        // known contract - no reentrancy guard needed\n        // slither-disable-next-line reentrancy-benign,reentrancy-no-eth,reentrancy-events\n        address vault = IPantherPoolV0(PANTHER_POOL).VAULT();\n\n        bool isUpdated = _updateNftRewardsLimitAndAllowance(\n            _desiredNftRewardsLimit,\n            _limits,\n            totals,\n            vault\n        );\n\n        if (isUpdated) {\n            limits = _limits;\n            emit RewardLimitUpdated(_limits);\n        }\n    }\n\n    /// @notice Allocate for rewards the entire $ZKP balance\n    /// this contract has and approve the Vault to transfer $ZKP from this contract.\n    /// @dev Anyone may call it.\n    function updateZkpRewardsLimit() external {\n        Limits memory _limits = limits;\n        // known contract call - no reentrancy guard needed\n        // slither-disable-next-line reentrancy-benign,reentrancy-events\n        address vault = IPantherPoolV0(PANTHER_POOL).VAULT();\n\n        // Updating the rewards limits\n        bool isUpdated = _updateZkpRewardsLimitAndAllowance(\n            _limits,\n            totals,\n            vault\n        );\n\n        if (isUpdated) {\n            limits = _limits;\n            emit RewardLimitUpdated(_limits);\n        }\n    }\n\n    /// @notice Withdraws unclaimed rewards or accidentally sent token from this contract\n    /// @dev May be only called by the {OWNER}\n    function rescueErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external nonReentrant {\n        RewardParams memory _rewardParams = rewardParams;\n\n        require(OWNER == msg.sender, \"ARC: unauthorized\");\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(\n            (token != ZKP_TOKEN) || (block.timestamp > _rewardParams.endTime),\n            \"ARC: too early withdrawal\"\n        );\n\n        _claimErc20(token, to, amount);\n    }\n\n    // Implementation of the {IERC721Receiver}. It accepts NFT_TOKEN transfers only.\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external view override returns (bytes4) {\n        return\n            msg.sender == NFT_TOKEN\n                ? this.onERC721Received.selector // accepted\n                : bytes4(0); // rejected\n    }\n\n    // Private functions follow\n    // Some of them declared `internal` rather than `private` to ease testing\n\n    function _generateRewards(bytes memory message) internal {\n        // (stakeId and claimedAt are irrelevant)\n        (\n            address staker,\n            uint96 stakeAmount,\n            ,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            ,\n            bytes memory data\n        ) = _unpackStakingActionMsg(message);\n\n        require(stakeAmount != 0, \"ARC: unexpected zero stakeAmount\");\n        require(lockedTill > stakedAt, \"ARC: unexpected lockedTill\");\n\n        uint256 zkpAmount = 0;\n        uint256 nftAmount = 0;\n        uint256 nftTokenId = 0;\n        {\n            Totals memory _totals = totals;\n            Limits memory _limits = limits;\n            RewardParams memory _rewardParams = rewardParams;\n\n            // Compute amount of the $ZKP reward  and check the limit\n            {\n                zkpAmount = _computeZkpReward(\n                    stakeAmount,\n                    lockedTill,\n                    stakedAt,\n                    _rewardParams\n                );\n\n                if (zkpAmount > 0) {\n                    uint256 newTotalZkpReward = uint256(_totals.zkpRewards) +\n                        zkpAmount;\n                    require(\n                        _limits.zkpRewards >= newTotalZkpReward,\n                        \"ARC: too less rewards available\"\n                    );\n                    // Can't exceed uint96 here due to the `require` above\n                    _totals.zkpRewards = uint96(newTotalZkpReward);\n                }\n                // update scSkpStaked in any case when stakeAmount > 0 which already been required\n                uint256 newScZkpStaked = uint256(_totals.scZkpStaked) +\n                    uint256(stakeAmount) /\n                    1e15;\n                // Overflow risk ignored as $ZKP max total supply is 1e9 tokens\n                _totals.scZkpStaked = uint40(newScZkpStaked);\n            }\n\n            if (_totals.nftRewards < _limits.nftRewards) {\n                // `_limits.nftRewards > 0` therefore `NFT_TOKEN != address(0)`\n                // trusted contract called - no reentrancy guard needed\n                // slither-disable-next-line reentrancy-benign,reentrancy-no-eth\n                nftTokenId = INftGrantor(NFT_TOKEN).grantOneToken(\n                    address(this)\n                );\n\n                nftAmount = 1;\n                _totals.nftRewards += 1;\n            }\n\n            totals = _totals;\n        }\n\n        // Extract public spending keys and \"secrets\"\n        (\n            G1Point[OUT_RWRD_UTXOs] memory pubSpendingKeys,\n            uint256[CIPHERTEXT1_WORDS][OUT_RWRD_UTXOs] memory secrets\n        ) = unpackStakingData(data);\n\n        // Finally, generate deposits (i.e. UTXOs in the MASP)\n        address[OUT_MAX_UTXOs] memory tokens = [\n            // PantherPool reverts if non-zero address provided for zero amount\n            zkpAmount == 0 ? address(0) : ZKP_TOKEN,\n            nftAmount == 0 ? address(0) : NFT_TOKEN,\n            ZERO_TOKEN\n        ];\n\n        uint256[OUT_MAX_UTXOs] memory subIds = [0, nftTokenId, ZERO_TOKEN_ID];\n        uint256[OUT_MAX_UTXOs] memory extAmounts = [\n            zkpAmount,\n            nftAmount,\n            ZERO_AMOUNT\n        ];\n\n        uint32 createdAt = safe32TimeNow();\n        // known contract call - no reentrancy guard needed\n        // slither-disable-next-line reentrancy-benign,reentrancy-events\n        uint256 leftLeafId = IPantherPoolV0(PANTHER_POOL).generateDeposits(\n            tokens,\n            subIds,\n            extAmounts,\n            [\n                pubSpendingKeys[0],\n                pubSpendingKeys[1],\n                pubSpendingKeys[1] // dummy public key - reused\n            ],\n            [\n                secrets[0],\n                secrets[1],\n                secrets[1] // dummy secret - reused\n            ],\n            createdAt\n        );\n\n        emit RewardGenerated(staker, leftLeafId, zkpAmount, nftAmount);\n    }\n\n    // The calling code is assumed to ensure `lockedTill > stakedAt`\n    function _computeZkpReward(\n        uint256 stakeAmount,\n        uint256 lockedTill,\n        uint256 stakedAt,\n        RewardParams memory _rewardParams\n    ) internal pure returns (uint256 zkpAmount) {\n        // No rewarding after `endTime`\n        if (stakedAt >= _rewardParams.endTime) return 0;\n        // No rewarding before `startTime`\n        if (lockedTill <= _rewardParams.startTime) return 0;\n\n        uint256 rewardedSince = _rewardParams.startTime > stakedAt\n            ? _rewardParams.startTime\n            : stakedAt;\n\n        uint256 rewardedTill = lockedTill > _rewardParams.endTime\n            ? _rewardParams.endTime\n            : lockedTill;\n\n        uint256 period = rewardedTill - rewardedSince;\n        uint256 apy = _getZkpApyWithinRewardedPeriod(\n            _rewardParams,\n            rewardedSince\n        );\n\n        // 3153600000 = 365 * 24 * 3600 seconds * 100 percents\n        // slither-disable-next-line too-many-digits\n        zkpAmount = (stakeAmount * apy * period) / 3153600000;\n        // round to 2nd digits after decimal point: X.YZ{0..0} x 1e18\n        unchecked {\n            // rounding (accuracy loss is assumed)\n            // slither-disable-next-line divide-before-multiply\n            zkpAmount = (zkpAmount / 1e16) * (1e16);\n        }\n    }\n\n    // The calling code is assumed to ensure that\n    // `startTime < time < endTime` and `startZkpApy >= endZkpApy`\n    function _getZkpApyWithinRewardedPeriod(\n        RewardParams memory _rewardParams,\n        uint256 time\n    ) private pure returns (uint256 apy) {\n        unchecked {\n            uint256 fullDrop = uint256(\n                _rewardParams.startZkpApy - _rewardParams.endZkpApy\n            );\n            apy = uint256(_rewardParams.startZkpApy);\n\n            if (fullDrop > 0) {\n                uint256 dropDuration = time - _rewardParams.startTime;\n                uint256 fullDuration = uint256(\n                    _rewardParams.endTime - _rewardParams.startTime\n                );\n                uint256 apyDrop = (fullDrop * dropDuration) / fullDuration;\n\n                apy -= apyDrop;\n            }\n        }\n    }\n\n    // Allocate for rewards the entire $ZKP balance this contract holds,\n    // and update allowance for the VAULT to spend for $ZKP from the balance\n    function _updateZkpRewardsLimitAndAllowance(\n        Limits memory _limits,\n        Totals memory _totals,\n        address vault\n    ) private returns (bool isUpdated) {\n        // Reentrancy guard unneeded for the trusted contract call\n        // slither-disable-next-line reentrancy-benign,reentrancy-events,reentrancy-no-eth\n        uint256 balance = ZKP_TOKEN.safeBalanceOf(address(this));\n\n        uint96 newLimit;\n        (isUpdated, newLimit) = _getUpdatedLimit(\n            balance,\n            _limits.zkpRewards,\n            _totals.zkpRewards\n        );\n\n        if (isUpdated) {\n            _limits.zkpRewards = newLimit;\n\n            // Approve the vault to transfer tokens from this contract\n            // Reentrancy guard unneeded for the trusted contract call\n            // slither-disable-next-line reentrancy-benign,reentrancy-events,reentrancy-no-eth\n            ZKP_TOKEN.safeApprove(vault, uint256(newLimit));\n        }\n    }\n\n    // Allocate for rewards the entire NFT amount this contract can mint,\n    // and update allowance for the VAULT to spend that NFT\n    function _updateNftRewardsLimitAndAllowance(\n        uint256 _desiredNftRewardsLimit,\n        Limits memory _limits,\n        Totals memory _totals,\n        address vault\n    ) private returns (bool isUpdated) {\n        uint96 newLimit;\n        (isUpdated, newLimit) = _getUpdatedLimit(\n            _desiredNftRewardsLimit,\n            _limits.nftRewards,\n            _totals.nftRewards\n        );\n\n        if (isUpdated) {\n            bool isAllowanceToBeUpdated = _limits.nftRewards == 0;\n\n            // Overflow is unrealistic and therefore ignored\n            _limits.nftRewards = uint24(newLimit);\n\n            if (isAllowanceToBeUpdated)\n                // Approve the vault to transfer tokens from this contract\n                // Reentrancy guard unneeded for the trusted contract call\n                // slither-disable-next-line reentrancy-benign,reentrancy-no-eth,reentrancy-events\n                NFT_TOKEN.safeSetApprovalForAll(vault, true);\n        }\n    }\n\n    // Calculates and returns the updated reward limit\n    function _getUpdatedLimit(\n        uint256 available,\n        uint96 currentLimit,\n        uint96 usedLimit\n    ) internal pure returns (bool isUpdated, uint96 limit) {\n        uint256 unusedLimit = uint256(currentLimit) - uint256(usedLimit);\n\n        if (available == unusedLimit) return (false, currentLimit);\n\n        isUpdated = true;\n        // underflow is impossible due to `if` checks\n        unchecked {\n            if (available > unusedLimit) {\n                // new tokens for rewarding have been provided\n                uint256 newAllocation = available - unusedLimit;\n                limit = safe96(newAllocation + currentLimit);\n            } else {\n                // gracefully handle this unexpected situation\n                uint96 shortage = safe96(unusedLimit - available);\n                limit = currentLimit > shortage ? currentLimit - shortage : 0;\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/actions/AdvancedStakingDataDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { CIPHERTEXT1_WORDS, OUT_RWRD_UTXOs, PUBKEY_WORDS } from \"../../common/Constants.sol\";\nimport { G1Point } from \"../../common/Types.sol\";\n\n/***\n * @title AdvancedStakingDataDecoder\n * @dev It decodes (unpack) `bytes data` of the 'STAKED' message for \"advanced staking\"\n */\nabstract contract AdvancedStakingDataDecoder {\n    // in bytes\n    uint256 private constant DATA_LENGTH =\n        OUT_RWRD_UTXOs * (PUBKEY_WORDS + CIPHERTEXT1_WORDS) * 32;\n    // in 32-byte memory slots\n    uint256 private constant NUM_DATA_SLOTS =\n        (DATA_LENGTH / 32) + ((DATA_LENGTH % 32) & 1);\n\n    // For efficiency we use \"packed\" (rather than \"ABI\") encoding.\n    // It results in shorter data, but requires custom unpack function.\n    function unpackStakingData(bytes memory data)\n        internal\n        pure\n        returns (\n            G1Point[OUT_RWRD_UTXOs] memory pubSpendingKeys,\n            uint256[CIPHERTEXT1_WORDS][OUT_RWRD_UTXOs] memory secrets\n        )\n    {\n        require(data.length == DATA_LENGTH, \"SMP: unexpected msg length\");\n\n        // Let's read bytes as uint256 values\n        uint256[NUM_DATA_SLOTS + 1] memory words;\n        // the 1st slot is `data.length`, then slots with values follow\n        for (uint256 i = 1; i <= NUM_DATA_SLOTS; ++i) {\n            // solhint-disable no-inline-assembly\n            // slither-disable-next-line assembly\n            assembly {\n                let offset := mul(i, 0x20)\n                let word := mload(add(data, offset))\n                mstore(add(words, offset), word)\n            }\n            // solhint-enable no-inline-assembly\n        }\n        /*\n            `bytes memory sample = 0x00010203..1f2021` stored in the memory like this:\n            slot #0: 0x22 - length (34 bytes)\n            slot #1: 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n            slot #2: 0x2021000000000000000000000000000000000000000000000000000000000000\n\n            If `OUT_RWRD_UTXOs == 2` and `CIPHERTEXT1_WORDS == 2`,\n            `bytes memory data` expected to be:\n            concatenate( // each element is 32-byte long\n                pubSpendingKeys[0].x, pubSpendingKeys[0].y,\n                pubSpendingKeys[1].x, pubSpendingKeys[1].y,\n                (secrets[0])[0], (secrets[0])[1],\n                (secrets[1])[0], (secrets[1])[1]\n            )\n        */\n        for (uint256 i = 0; i < OUT_RWRD_UTXOs; i++) {\n            pubSpendingKeys[i].x = words[i * PUBKEY_WORDS + 1];\n            pubSpendingKeys[i].y = words[i * PUBKEY_WORDS + 2];\n            for (uint256 k = 0; k < CIPHERTEXT1_WORDS; k++) {\n                secrets[i][k] = words[\n                    PUBKEY_WORDS *\n                        OUT_RWRD_UTXOs +\n                        CIPHERTEXT1_WORDS *\n                        i +\n                        k +\n                        1\n                ];\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/actions/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// solhint-disable var-name-mixedcase\n\n// The \"stake type\" for the \"classic staking\"\n// bytes4(keccak256(\"classic\"))\nbytes4 constant CLASSIC_STAKE_TYPE = 0x4ab0941a;\n\n// STAKE \"action type\" for the \"classic staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"stake\"), CLASSIC_STAKE_TYPE)))\nbytes4 constant CLASSIC_STAKE = 0x1e4d02b5;\n\n// UNSTAKE \"action type\" for the \"classic staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"unstake\"), CLASSIC_STAKE_TYPE)))\nbytes4 constant CLASSIC_UNSTAKE = 0x493bdf45;\n\n// The \"stake type\" for the \"advance staking\"\n// bytes4(keccak256(\"advanced\"))\nbytes4 constant ADVANCED_STAKE_TYPE = 0x7ec13a06;\n\n// STAKE \"action type\" for the \"advanced staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"stake\"), ADVANCED_STAKE_TYPE)))\nbytes4 constant ADVANCED_STAKE = 0xcc995ce8;\n\n// UNSTAKE \"action type\" for the \"advanced staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"unstake\"), ADVANCED_STAKE_TYPE)))\nbytes4 constant ADVANCED_UNSTAKE = 0xb8372e55;\n\n// PRP grant type for the \"advanced\" stake\n// bytes4(keccak256(\"forAdvancedStakeGrant\"))\nbytes4 constant FOR_ADVANCED_STAKE_GRANT = 0x31a180d4;\n\n// solhint-enable var-name-mixedcase\n"
    },
    "contracts/staking/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient,\n     * the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/staking/interfaces/INftGrantor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface INftGrantor {\n    function grantOneToken(address to) external returns (uint256 tokenId);\n}\n"
    },
    "contracts/staking/interfaces/IPantherPoolV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport { G1Point } from \"../../common/Types.sol\";\nimport { CIPHERTEXT1_WORDS, OUT_MAX_UTXOs, PATH_ELEMENTS_NUM } from \"../../common/Constants.sol\";\n\n/**\n * @notice (Truncated) Interface of the PantherPoolV0\n * @dev Only those functions and events included which the `AdvancedStakeRewardController` contract uses\n */\ninterface IPantherPoolV0 {\n    /**\n     * @notice Transfer assets from the msg.sender to the VAULT and generate UTXOs in the MASP\n     * @param tokens Address of the token contract for every UTXO\n     * @dev For PRP granted the address ot this contract (proxy) is supposed to be used\n     * @param tokenIds For ERC-721 and ERC-1155 - token ID or subId of the token, 0 for ERC-20\n     * @param extAmounts Token amounts (external) to be deposited\n     * @param pubSpendingKeys Public Spending Key for every UTXO\n     * @param secrets Encrypted opening values for every UTXO\n     * @param  createdAt Optional, if 0 network time used\n     * @dev createdAt must be less (or equal) the network time\n     * @return leftLeafId The `leafId` of the first UTXO (leaf) in the batch\n     */\n    function generateDeposits(\n        address[OUT_MAX_UTXOs] calldata tokens,\n        uint256[OUT_MAX_UTXOs] calldata tokenIds,\n        uint256[OUT_MAX_UTXOs] calldata extAmounts,\n        G1Point[OUT_MAX_UTXOs] calldata pubSpendingKeys,\n        uint256[CIPHERTEXT1_WORDS][OUT_MAX_UTXOs] calldata secrets,\n        uint32 createdAt\n    ) external returns (uint256 leftLeafId);\n\n    function exit(\n        address token,\n        uint256 tokenId,\n        uint256 amount,\n        uint32 creationTime,\n        uint256 privSpendingKey,\n        uint256 leafId,\n        bytes32[PATH_ELEMENTS_NUM] calldata pathElements,\n        bytes32 merkleRoot,\n        uint256 cacheIndexHint\n    ) external;\n\n    /**\n     * @return Address of the Vault\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function VAULT() external view returns (address);\n\n    /**\n     * @dev Emitted on a new batch of Commitments\n     * @param leftLeafId The `leafId` of the first leaf in the batch\n     * @dev `leafId = leftLeafId + 1` for the 2nd leaf (`leftLeafId + 2` for the 3rd leaf)\n     * @param commitments Commitments hashes\n     * @param utxoData opening values (encrypted and public) for UTXOs\n     */\n    event NewCommitments(\n        uint256 indexed leftLeafId,\n        uint256 creationTime,\n        bytes32[OUT_MAX_UTXOs] commitments,\n        bytes utxoData\n    );\n\n    /**\n     * Nullifier is seen (i.e. UTXO is spent)\n     */\n    event Nullifier(bytes32 nullifier);\n}\n"
    },
    "contracts/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// Constants\n\nuint256 constant IN_PRP_UTXOs = 1;\nuint256 constant IN_UTXOs = 2 + IN_PRP_UTXOs;\n\nuint256 constant OUT_PRP_UTXOs = 1;\nuint256 constant OUT_UTXOs = 2 + OUT_PRP_UTXOs;\nuint256 constant OUT_MAX_UTXOs = OUT_UTXOs;\n// Number of UTXOs given as a reward for an \"advanced\" stake\nuint256 constant OUT_RWRD_UTXOs = 2;\n\n// For overflow protection and circuits optimization\n// (must be less than the FIELD_SIZE)\nuint256 constant MAX_EXT_AMOUNT = 2**96;\nuint256 constant MAX_IN_CIRCUIT_AMOUNT = 2**64;\nuint256 constant MAX_TIMESTAMP = 2**32;\nuint256 constant MAX_ZASSET_ID = 2**160;\n\n// Token types\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant ERC20_TOKEN_TYPE = 0x00;\nuint8 constant ERC721_TOKEN_TYPE = 0x10;\nuint8 constant ERC1155_TOKEN_TYPE = 0x11;\n// defined for every tokenId rather than for all tokens on the contract\n// (unsupported in the V0 and V1 of the MASP)\nuint8 constant BY_TOKENID_TOKEN_TYPE = 0xFF;\n\n// ZAsset statuses\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant zASSET_ENABLED = 0x01;\nuint8 constant zASSET_DISABLED = 0x02;\nuint8 constant zASSET_UNKNOWN = 0x00;\n\n// UTXO data (opening values - encrypted and public) formats\nuint8 constant UTXO_DATA_TYPE5 = 0x00; // for zero UTXO (no data to provide)\nuint8 constant UTXO_DATA_TYPE1 = 0x01; // for UTXO w/ zero tokenId\nuint8 constant UTXO_DATA_TYPE3 = 0x02; // for UTXO w/ non-zero tokenId\n\n// Number of 32-bit words of the CiphertextMsg for UTXO_DATA_TYPE1\n// (ephemeral key (packed) - 32 bytes, encrypted `random` - 32 bytes)\nuint256 constant CIPHERTEXT1_WORDS = 2;\n\n// Number of 32-bit words in the (uncompressed) spending PubKey\nuint256 constant PUBKEY_WORDS = 2;\n// Number of elements in `pathElements`\nuint256 constant PATH_ELEMENTS_NUM = 16;\n"
    },
    "contracts/common/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nstruct G1Point {\n    uint256 x;\n    uint256 y;\n}\n\n// Encoding of field elements is: X[0] * z + X[1]\nstruct G2Point {\n    uint256[2] x;\n    uint256[2] y;\n}\n\n// Verification key for SNARK\nstruct VerifyingKey {\n    G1Point alpha1;\n    G2Point beta2;\n    G2Point gamma2;\n    G2Point delta2;\n    G1Point[2] ic;\n}\n\nstruct SnarkProof {\n    G1Point a;\n    G2Point b;\n    G1Point c;\n}\n\nstruct PluginData {\n    address contractAddress;\n    bytes callData;\n}\n\nstruct ElGamalCiphertext {\n    G1Point c1;\n    G1Point c2;\n}\n\n// For MASP V0 and V1\nstruct ZAsset {\n    // reserved (for networkId, tokenIdPolicy. etc..)\n    uint64 _unused;\n    // 0x00 by default\n    uint8 version;\n    // Refer to Constants.sol\n    uint8 status;\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // 0x00 - no scaling\n    uint8 scale;\n    // token contract address\n    address token;\n}\n\nstruct LockData {\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // Token contract address\n    address token;\n    // For ERC-721, ERC-1155 tokens\n    uint256 tokenId;\n    // The account to transfer the token from/to (on `lock`/`unlock`)\n    address extAccount;\n    // The token amount to transfer to/from the Vault (on `lock`/`unlock`)\n    uint96 extAmount;\n}\n"
    },
    "contracts/staking/mocks/MockAdvancedStakeRewardController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.16;\n\nimport \"../AdvancedStakeRewardController.sol\";\n\ncontract MockAdvancedStakeRewardController is AdvancedStakeRewardController {\n    constructor(\n        address _owner,\n        address rewardMaster,\n        address pantherPool,\n        address zkpToken,\n        address nftToken\n    )\n        AdvancedStakeRewardController(\n            _owner,\n            rewardMaster,\n            pantherPool,\n            zkpToken,\n            nftToken\n        )\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    function internalComputeZkpReward(\n        uint256 stakeAmount,\n        uint32 lockedTill,\n        uint32 stakedAt,\n        RewardParams memory _rewardParams\n    ) external pure returns (uint256 zkpAmount) {\n        return\n            _computeZkpReward(stakeAmount, lockedTill, stakedAt, _rewardParams);\n    }\n\n    function internalGenerateRewards(bytes calldata message) external {\n        _generateRewards(message);\n    }\n\n    function internalGetUpdatedLimit(\n        uint256 available,\n        uint96 currentLimit,\n        uint96 usedLimit\n    ) external pure returns (bool isUpdated, uint96 limit) {\n        return _getUpdatedLimit(available, currentLimit, usedLimit);\n    }\n\n    function fakeTotals(Totals memory _totals) external {\n        totals = _totals;\n    }\n}\n"
    },
    "contracts/protocol/Vault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport { ERC20_TOKEN_TYPE, ERC721_TOKEN_TYPE, ERC1155_TOKEN_TYPE } from \"../common/Constants.sol\";\nimport \"./errMsgs/VaultErrMsgs.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/TransferHelper.sol\";\nimport { LockData } from \"../common/Types.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./vault/OnERC1155Received.sol\";\nimport \"./vault/OnERC721Received.sol\";\n\n/**\n * @title Vault\n * @author Pantherprotocol Contributors\n * @notice Holder of assets (tokens) for `PantherPool` contract\n * @dev It transfers assets from user to itself (Lock) and vice versa (Unlock).\n * `PantherPool` is assumed to be the `owner` that is authorized to trigger\n * locking/unlocking assets.\n */\ncontract Vault is\n    ImmutableOwnable,\n    OnERC721Received,\n    OnERC1155Received,\n    IVault\n{\n    using TransferHelper for address;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) ImmutableOwnable(_owner) {\n        // Proxy-friendly: no storage initialization\n    }\n\n    // The caller (i.e. the owner) is supposed to apply reentrancy guard.\n    // If an adversarial \"token\", being called by this function, re-enters it\n    // directly, `onlyOwner` will revert as `msg.sender` won't be `owner`.\n    function lockAsset(LockData calldata data)\n        external\n        override\n        onlyOwner\n        checkLockData(data)\n    {\n        if (data.tokenType == ERC20_TOKEN_TYPE) {\n            // Owner, who only may call this code, is trusted to protect\n            // against \"Arbitrary from in transferFrom\" vulnerability\n            // slither-disable-next-line arbitrary-send-erc20,reentrancy-benign,reentrancy-events\n            data.token.safeTransferFrom(\n                data.extAccount,\n                address(this),\n                data.extAmount\n            );\n        } else if (data.tokenType == ERC721_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc721SafeTransferFrom(\n                data.tokenId,\n                data.extAccount,\n                address(this)\n            );\n        } else if (data.tokenType == ERC1155_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc1155SafeTransferFrom(\n                data.extAccount,\n                address(this),\n                data.tokenId,\n                uint256(data.extAmount),\n                new bytes(0)\n            );\n        } else {\n            revert(ERR_INVALID_TOKEN_TYPE);\n        }\n\n        emit Locked(data);\n    }\n\n    // The caller (i.e. the owner) is supposed to apply reentrancy guard.\n    // If an adversarial \"token\", being called by this function, re-enters it\n    // directly, `onlyOwner` will revert as `msg.sender` won't be `owner`.\n    function unlockAsset(LockData calldata data)\n        external\n        override\n        onlyOwner\n        checkLockData(data)\n    {\n        if (data.tokenType == ERC20_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.safeTransfer(data.extAccount, data.extAmount);\n        } else if (data.tokenType == ERC721_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc721SafeTransferFrom(\n                data.tokenId,\n                address(this),\n                data.extAccount\n            );\n        } else if (data.tokenType == ERC1155_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc1155SafeTransferFrom(\n                address(this),\n                data.extAccount,\n                data.tokenId,\n                data.extAmount,\n                new bytes(0)\n            );\n        } else {\n            revert(ERR_INVALID_TOKEN_TYPE);\n        }\n\n        emit Unlocked(data);\n    }\n\n    modifier checkLockData(LockData calldata data) {\n        require(data.token != address(0), ERR_ZERO_LOCK_TOKEN_ADDR);\n        require(data.extAccount != address(0), ERR_ZERO_EXT_ACCOUNT_ADDR);\n        require(data.extAmount > 0, ERR_ZERO_EXT_AMOUNT);\n        _;\n    }\n}\n"
    },
    "contracts/protocol/errMsgs/VaultErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INVALID_TOKEN_TYPE = \"VA:E1\";\nstring constant ERR_ZERO_LOCK_TOKEN_ADDR = \"VA:E2\";\nstring constant ERR_ZERO_EXT_ACCOUNT_ADDR = \"VA:E3\";\nstring constant ERR_ZERO_EXT_AMOUNT = \"VA:E4\";\n"
    },
    "contracts/protocol/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IVault {\n    function lockAsset(LockData calldata data) external;\n\n    function unlockAsset(LockData memory data) external;\n\n    event Locked(LockData data);\n    event Unlocked(LockData data);\n}\n"
    },
    "contracts/protocol/vault/OnERC1155Received.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/// @dev Implementation of ERC1155:onERC1155Received interface\nabstract contract OnERC1155Received {\n    // It accepts all tokens\n    function onERC1155Received(\n        address, /* operator */\n        address, /* from */\n        uint256, /* id */\n        uint256, /* value */\n        bytes calldata /* data */\n    ) external pure virtual returns (bytes4) {\n        // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n        return 0xf23a6e61;\n    }\n}\n"
    },
    "contracts/protocol/vault/OnERC721Received.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/// @dev Implementation of the ERC721TokenReceiver interface\nabstract contract OnERC721Received {\n    // It accepts all tokens\n    function onERC721Received(\n        address, // operator\n        address, // from\n        uint256, // tokenId\n        bytes memory // data\n    ) external virtual returns (bytes4) {\n        // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n        return 0x150b7a02;\n    }\n}\n"
    },
    "contracts/protocol/PantherPoolV0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../common/Constants.sol\";\nimport \"./errMsgs/PantherPoolErrMsgs.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/NonReentrant.sol\";\nimport \"../common/Types.sol\";\nimport \"../common/Utils.sol\";\nimport \"./interfaces/IPrpGrantor.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IZAssetsRegistry.sol\";\nimport \"../common/Claimable.sol\";\nimport \"./pantherPool/AmountConvertor.sol\";\nimport \"./pantherPool/CommitmentGenerator.sol\";\nimport \"./pantherPool/CommitmentsTrees.sol\";\nimport \"./pantherPool/MerkleProofVerifier.sol\";\nimport \"./pantherPool/NullifierGenerator.sol\";\nimport \"./pantherPool/PubKeyGenerator.sol\";\n\n/**\n * @title PantherPool\n * @author Pantherprotocol Contributors\n * @notice Multi-Asset Shielded Pool main contract v0\n * @dev It is the \"version 0\" of the Panther Protocol Multi-Asset Shielded Pool (\"MASP\").\n * It locks assets (ERC-20, ERC-721 or ERC-1155 tokens) of a user with the `Vault` smart\n * contract and generates UTXO's in the MASP for the user (i.e. builds merkle trees of\n * UTXO's commitments).\n * This contract does not implement the functionality for spending UTXO's (other than the\n * `exit` described further) and is supposed to be upgraded with the new one.\n * The new contract, the \"v.1\" of the MASP, is planned to implement spending of UTXO's\n * using zero-knowledge proves.\n * To be upgradable, this contract is assumed to run as an \"implementation\" for a proxy\n * that DELEGATECALL's the implementation.\n * To protect holders against lost of assets in case this contract is not upgraded, it\n * exposes the `exit` function, through which users may withdraw their locked assets via\n * revealing preimages of commitments.\n */\ncontract PantherPoolV0 is\n    ImmutableOwnable,\n    NonReentrant,\n    Claimable,\n    CommitmentsTrees,\n    AmountConvertor,\n    CommitmentGenerator,\n    MerkleProofVerifier,\n    NullifierGenerator,\n    PubKeyGenerator,\n    Utils\n{\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    /// @notice Address of the ZAssetRegistry contract\n    address public immutable ASSET_REGISTRY;\n\n    /// @notice Address of the Vault contract\n    address public immutable VAULT;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice (UNIX) Time since when the `exit` calls get enabled\n    uint32 public exitTime;\n\n    /// @notice Period (seconds) since `commitToExit` when `exit` opens\n    // Needed to mitigate front-run attacks on `exit`\n    uint24 public exitDelay;\n\n    // (rest of the storage slot) reserved for upgrades\n    // slither-disable-next-line unused-state,constable-states\n    uint200 private _reserved;\n\n    // @notice Seen (i.e. spent) commitment nullifiers\n    // nullifier hash => spent\n    mapping(bytes32 => bool) public isSpent;\n\n    /// @notice Unused registered commitments to exit\n    // hash(privSpendKey, recipient) => commitment timestamp\n    mapping(bytes32 => uint32) public exitCommitments;\n\n    /// @dev Emitted when exit time and/or exit delay updated\n    event ExitTimesUpdated(uint256 newExitTime, uint256 newExitDelay);\n\n    /// @dev New nullifier has been seen\n    event Nullifier(bytes32 nullifier);\n\n    /// @dev A tiny disowned token amount gets locked in the Vault\n    /// (as a result of imprecise scaling of deposited amounts)\n    event Change(address indexed token, uint256 change);\n\n    /// @dev New exit commitment registered\n    event ExitCommitment(uint256 timestamp);\n\n    /// @param _owner Address of the `OWNER` who may call `onlyOwner` methods\n    /// @param assetRegistry Address of the ZAssetRegistry contract\n    /// @param vault Address of the Vault contract\n    constructor(\n        address _owner,\n        address assetRegistry,\n        address vault\n    ) ImmutableOwnable(_owner) {\n        require(TRIAD_SIZE == OUT_UTXOs, \"E0\");\n\n        revertZeroAddress(assetRegistry);\n        revertZeroAddress(vault);\n\n        // As it runs behind the DELEGATECALL'ing proxy, initialization of\n        // immutable \"vars\" only is allowed in the constructor\n\n        ASSET_REGISTRY = assetRegistry;\n        VAULT = vault;\n    }\n\n    /// @notice Update the exit time and the exit delay\n    /// @dev Owner only may calls\n    function updateExitTimes(uint32 newExitTime, uint24 newExitDelay)\n        external\n        onlyOwner\n    {\n        require(\n            newExitTime >= exitTime &&\n                newExitTime < MAX_TIMESTAMP &&\n                newExitDelay != 0,\n            \"E1\"\n        );\n\n        exitTime = newExitTime;\n        exitDelay = newExitDelay;\n\n        emit ExitTimesUpdated(uint256(newExitTime), uint256(newExitDelay));\n    }\n\n    /// @notice Transfer assets from the msg.sender to the VAULT and generate UTXOs in the MASP\n    /// @param tokens Address of the token contract for every UTXO\n    /// @param tokenIds For ERC-721 and ERC-1155 - token ID or subId of the token, 0 for ERC-20\n    /// @param amounts Token amounts (unscaled) to be deposited\n    /// @param pubSpendingKeys Public Spending Key for every UTXO\n    /// @param secrets Encrypted opening values for every UTXO\n    /// @param createdAt Optional, if 0 the network time used\n    /// @dev createdAt must be less (or equal) the network time\n    /// @return leftLeafId The `leafId` of the first UTXO (leaf) in the batch\n    function generateDeposits(\n        address[OUT_MAX_UTXOs] calldata tokens,\n        uint256[OUT_MAX_UTXOs] calldata tokenIds,\n        uint256[OUT_MAX_UTXOs] calldata amounts,\n        G1Point[OUT_MAX_UTXOs] calldata pubSpendingKeys,\n        uint256[CIPHERTEXT1_WORDS][OUT_MAX_UTXOs] calldata secrets,\n        uint32 createdAt\n    ) external nonReentrant returns (uint256 leftLeafId) {\n        require(exitTime > 0, ERR_UNCONFIGURED_EXIT_TIME);\n\n        uint32 timestamp = safe32TimeNow();\n        if (createdAt != 0) {\n            // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n            // slither-disable-next-line timestamp\n            require(createdAt <= timestamp, ERR_TOO_EARLY_CREATED_AT);\n            timestamp = createdAt;\n        }\n\n        // variables get initialized inside the loop bellow\n        // slither-disable-next-line uninitialized-local\n        bytes32[OUT_MAX_UTXOs] memory commitments;\n        // slither-disable-next-line uninitialized-local\n        bytes[OUT_MAX_UTXOs] memory perUtxoData;\n\n        // Types of UTXO data messages packed into one byte\n        uint8 msgTypes = uint8(0);\n\n        for (uint256 utxoIndex = 0; utxoIndex < OUT_MAX_UTXOs; utxoIndex++) {\n            // The next call can't trigger the \"calls loop\" since it triggers\n            // external calls to known contracts, which are trusted to handle\n            // reentrancy risk properly.\n            // Slither's \"disable calls-loop detector\" directives are inserted\n            // in lines (bellow) with external calls rather than here only (as\n            // otherwise slither reports false-positive issues).\n            (uint160 zAssetId, uint64 scaledAmount) = _processDepositedAsset(\n                tokens[utxoIndex],\n                tokenIds[utxoIndex],\n                amounts[utxoIndex]\n            );\n\n            if (utxoIndex != 0) msgTypes = msgTypes << 2;\n\n            if (scaledAmount == 0) {\n                // the zero UTXO\n                // At least the 1st deposited amount shall be non-zero\n                require(utxoIndex != 0, ERR_ZERO_DEPOSIT);\n\n                commitments[utxoIndex] = ZERO_VALUE;\n                perUtxoData[utxoIndex] = \"\";\n                // As UTXO_DATA_TYPE5 is 0, next statement may be skipped\n                // msgTypes |= UTXO_DATA_TYPE5;\n            } else {\n                // non-zero UTXO\n                commitments[utxoIndex] = generateCommitment(\n                    pubSpendingKeys[utxoIndex].x,\n                    pubSpendingKeys[utxoIndex].y,\n                    scaledAmount,\n                    zAssetId,\n                    timestamp\n                );\n\n                uint256 zAssetIdAndAmount = (uint256(zAssetId) << 96) |\n                    uint256(scaledAmount);\n\n                if (tokenIds[utxoIndex] != 0) {\n                    msgTypes |= UTXO_DATA_TYPE1;\n                    perUtxoData[utxoIndex] = abi.encodePacked(\n                        secrets[utxoIndex],\n                        zAssetIdAndAmount\n                    );\n                } else {\n                    msgTypes |= UTXO_DATA_TYPE3;\n                    perUtxoData[utxoIndex] = abi.encodePacked(\n                        secrets[utxoIndex],\n                        zAssetIdAndAmount,\n                        tokenIds[utxoIndex]\n                    );\n                }\n            }\n        }\n\n        leftLeafId = addAndEmitCommitments(\n            commitments,\n            msgTypes,\n            perUtxoData,\n            timestamp\n        );\n    }\n\n    /// @notice Register future `exit` to protect against front-run and DoS.\n    /// The `exit` is possible only after `exitDelay` since this function call.\n    /// @param exitCommitment Commitment to the UTXO spending key and the recipient address.\n    /// MUST be equal to keccak256(abi.encode(uint256(privSpendingKey), address(recipient)).\n    function commitToExit(bytes32 exitCommitment) external {\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line incorrect-equality,timestamp\n        require(\n            exitCommitments[exitCommitment] == uint32(0),\n            ERR_EXITCOMMIT_EXISTS\n        );\n        uint32 timestamp = safe32TimeNow();\n        exitCommitments[exitCommitment] = timestamp;\n        emit ExitCommitment(timestamp);\n    }\n\n    /// @notice Spend an UTXO in the MASP and withdraw the asset from the Vault to the msg.sender.\n    /// This function call must be registered in advance with `commitToExit`.\n    /// @param token Address of the token contract\n    /// @param subId '_tokenId'/'_id' for ERC-721/1155, 0 for the \"default\" zAsset of an ERC-20 token,\n    // or `subId` for an \"alternative\" zAsset of an ERC-20 (see ZAssetRegistry.sol for details)\n    /// @param scaledAmount Token scaled amount\n    /// @param privSpendingKey UTXO's Private Spending Key\n    /// @param leafId Id of the leaf with the UTXO commitments in the Merkle Trees\n    /// @param pathElements Elements of the Merkle proof of inclusion\n    /// @param merkleRoot The root of the Merkle Tree the leaf is a part of\n    /// @param cacheIndexHint Index of the `merkleRoot` in the cache of roots, 0 by default\n    /// @dev `cacheIndexHint` needed for the \"current\" (partially populated) tree only\n    function exit(\n        address token,\n        uint256 subId,\n        uint64 scaledAmount,\n        uint32 creationTime,\n        uint256 privSpendingKey,\n        uint256 leafId,\n        bytes32[TREE_DEPTH + 1] calldata pathElements,\n        bytes32 merkleRoot,\n        uint256 cacheIndexHint\n    ) external nonReentrant {\n        // if exitTime == 0 -> `exit` is not accepted since init phase is not finished yet\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(\n            safe32TimeNow() >= exitTime && exitTime != 0,\n            ERR_TOO_EARLY_EXIT\n        );\n        _verifyExitCommitment(privSpendingKey, msg.sender);\n\n        {\n            bytes32 nullifier = generateNullifier(privSpendingKey, leafId);\n            require(!isSpent[nullifier], ERR_SPENT_NULLIFIER);\n            isSpent[nullifier] = true;\n            emit Nullifier(nullifier);\n        }\n        require(\n            isKnownRoot(getTreeId(leafId), merkleRoot, cacheIndexHint),\n            ERR_UNKNOWN_MERKLE_ROOT\n        );\n\n        ZAsset memory asset;\n        uint256 _tokenId;\n        {\n            bytes32 commitment;\n            {\n                uint160 zAssetId;\n                {\n                    (zAssetId, _tokenId, , asset) = IZAssetsRegistry(\n                        ASSET_REGISTRY\n                    ).getZAssetAndIds(token, subId);\n                    require(asset.status == zASSET_ENABLED, ERR_WRONG_ASSET);\n                }\n                G1Point memory pubSpendingKey = generatePubSpendingKey(\n                    privSpendingKey\n                );\n                commitment = generateCommitment(\n                    pubSpendingKey.x,\n                    pubSpendingKey.y,\n                    scaledAmount,\n                    zAssetId,\n                    creationTime\n                );\n            }\n            verifyMerkleProof(\n                merkleRoot,\n                _getTriadIndex(leafId),\n                _getTriadNodeIndex(leafId),\n                commitment,\n                pathElements\n            );\n        }\n\n        uint96 amount = _unscaleAmount(scaledAmount, asset.scale);\n        IVault(VAULT).unlockAsset(\n            LockData(asset.tokenType, token, _tokenId, msg.sender, amount)\n        );\n    }\n\n    /// @notice Withdraw accidentally sent tokens or ETH from this contract\n    /// @dev The \"owner\" may call only\n    function claimEthOrErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyOwner nonReentrant {\n        _claimEthOrErc20(token, to, amount);\n    }\n\n    /// Internal and private functions follow\n\n    // Declared `internal` rather than `private` to ease testing\n    function _processDepositedAsset(\n        address token,\n        uint256 subId,\n        uint256 amount\n    ) internal returns (uint160 zAssetId, uint64 scaledAmount) {\n        // Do nothing if it's the \"zero\" (or \"dummy\") deposit\n        if (amount == 0) {\n            // Both token and subId must be zeros for the \"zero\" deposit\n            require(token == address(0) && subId == 0, ERR_WRONG_DEPOSIT);\n            return (0, 0);\n        }\n        // amount can't be zero here and further\n\n        // At this point, a non-zero deposit of a real asset (token) expected\n        uint256 _tokenId;\n        ZAsset memory asset;\n\n        // Note comments on \"calls-loop\" in `function generateDeposits`\n        // slither-disable-next-line calls-loop\n        (zAssetId, _tokenId, , asset) = IZAssetsRegistry(ASSET_REGISTRY)\n            .getZAssetAndIds(token, subId);\n        require(asset.status == zASSET_ENABLED, ERR_WRONG_ASSET);\n\n        // Scale amount, if asset.scale provides for it (ERC-20 only)\n        uint256 change;\n        (scaledAmount, change) = _scaleAmount(amount, asset.scale);\n\n        // The `change` will remain locked in the Vault until it's claimed\n        // (when and if future upgrades implement change claiming)\n        if (change > 0) emit Change(token, change);\n\n        // slither-disable-next-line calls-loop\n        IVault(VAULT).lockAsset(\n            LockData(\n                asset.tokenType,\n                asset.token,\n                _tokenId,\n                msg.sender,\n                uint96(amount)\n            )\n        );\n\n        return (zAssetId, scaledAmount);\n    }\n\n    function _verifyExitCommitment(uint256 privSpendingKey, address recipient)\n        internal\n    {\n        bytes32 commitment = keccak256(abi.encode(privSpendingKey, recipient));\n\n        uint32 commitmentTime = exitCommitments[commitment];\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(commitmentTime != uint32(0), ERR_EXITCOMMIT_MISSING);\n\n        uint256 allowedTime = uint256(commitmentTime) + uint256(exitDelay);\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(timeNow() > allowedTime, ERR_EXITCOMMIT_LOCKED);\n\n        // Let's gain some gas back\n        exitCommitments[commitment] = uint32(0);\n        // No extra event emitted as spent UTXO and withdrawal events will fire\n    }\n}\n"
    },
    "contracts/protocol/errMsgs/PantherPoolErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n// CommitmentGenerator contract\nstring constant ERR_TOO_LARGE_PUBKEY = \"CG:E1\";\n\n// CommitmentsTrees contract\nstring constant ERR_TOO_LARGE_COMMITMENTS = \"CT:E1\"; // commitment exceeds maximum scalar field size\n\n// MerkleProofVerifier\nstring constant ERR_MERKLE_PROOF_VERIFICATION_FAILED = \"MP:E1\";\nstring constant ERR_TRIAD_INDEX_MIN_VALUE = \"MP:E2\";\nstring constant ERR_TRIAD_INDEX_MAX_VALUE = \"MP:E3\";\n\n// TriadIncrementalMerkleTrees contract\nstring constant ERR_ZERO_ROOT = \"TT:E1\"; // merkle tree root can not be zero\n\n// PantherPool contract\nstring constant ERR_DEPOSIT_OVER_LIMIT = \"PP:E1\";\nstring constant ERR_DEPOSIT_FROM_ZERO_ADDRESS = \"PP:E2\";\nstring constant ERR_EXITCOMMIT_EXISTS = \"PP:E32\";\nstring constant ERR_EXITCOMMIT_LOCKED = \"PP:E33\";\nstring constant ERR_EXITCOMMIT_MISSING = \"PP:E34\";\nstring constant ERR_EXPIRED_TX_TIME = \"PP:E3\";\nstring constant ERR_INVALID_JOIN_INPUT = \"PP:E4\";\nstring constant ERR_INVALID_PROOF = \"PP:E5\";\nstring constant ERR_MISMATCHED_ARR_LENGTH = \"PP:E6\";\nstring constant ERR_PLUGIN_FAILURE = \"PP:E7\";\nstring constant ERR_SPENT_NULLIFIER = \"PP:E8\";\nstring constant ERR_TOO_EARLY_CREATED_AT = \"PP:E9\";\nstring constant ERR_TOO_EARLY_EXIT = \"PP:E30\";\nstring constant ERR_TOO_LARGE_AMOUNT = \"PP:E10\";\nstring constant ERR_TOO_LARGE_COMMITMENT = \"PP:E11\";\nstring constant ERR_TOO_LARGE_NULLIFIER = \"PP:E12\";\nstring constant ERR_TOO_LARGE_LEAFID = \"PP:E27\";\nstring constant ERR_TOO_LARGE_PRIVKEY = \"PP:E28\";\nstring constant ERR_TOO_LARGE_ROOT = \"PP:E13\";\nstring constant ERR_TOO_LARGE_SCALED_AMOUNT = \"PP:E26\";\nstring constant ERR_TOO_LARGE_TIME = \"PP:E14\";\nstring constant ERR_UNCONFIGURED_EXIT_TIME = \"PP:E31\";\nstring constant ERR_UNKNOWN_MERKLE_ROOT = \"PP:E16\";\nstring constant ERR_WITHDRAW_OVER_LIMIT = \"PP:E17\";\nstring constant ERR_WITHDRAW_TO_ZERO_ADDRESS = \"PP:E18\";\nstring constant ERR_WRONG_ASSET = \"PP:E19\";\nstring constant ERR_WRONG_DEPOSIT = \"PP:E29\";\nstring constant ERR_WRONG_PRP_SUBID = \"PP:E25\";\nstring constant ERR_ZERO_DEPOSIT = \"PP:E21\";\nstring constant ERR_ZERO_FEE_PAYER = \"PP:E22\";\nstring constant ERR_ZERO_TOKEN_EXPECTED = \"PP:E23\";\nstring constant ERR_ZERO_TOKEN_UNEXPECTED = \"PP:E24\";\n"
    },
    "contracts/protocol/interfaces/IPrpGrantor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/**\n * @title IPrpGrantor\n * @notice Interface for the `PrpGrantor` contract\n * @dev Excluding `onlyOwner` functions\n */\ninterface IPrpGrantor {\n    /// @notice Return the address of the \"grant processor\"\n    /// @dev This account only is authorized to call `redeemGrant`\n    function grantProcessor() external view returns (address);\n\n    /// @notice Returns the total amount (in PRPs) of grants issued so far\n    /// (excluding burnt grants)\n    function totalGrantsIssued() external returns (uint256);\n\n    /// @notice Returns the total amount (in PRPs) of grants redeemed so far\n    function totalGrantsRedeemed() external returns (uint256);\n\n    /// @notice Returns the total amount (in PRPs) of unused grants for the given grantee\n    function getUnusedGrantAmount(address grantee)\n        external\n        view\n        returns (uint256 prpAmount);\n\n    /// @notice Returns the PRP amount of the grant specified by a given curator and type\n    function getGrantAmount(address curator, bytes4 grantType)\n        external\n        view\n        returns (uint256 prpAmount);\n\n    /// @notice Increase the amount of \"unused\" grants for the given grantee, by the amount\n    /// defined for the given \"grant type\"\n    /// @return prpAmount The amount (in PRPs) of the grant\n    /// @dev An authorized \"curator\" may call with the enabled (added) \"grant type\" only\n    function issueGrant(address grantee, bytes4 grantType)\n        external\n        returns (uint256 prpAmount);\n\n    /// @notice Increase the amount of \"unused\" grants for the given grantee, by the amount\n    /// specified.\n    /// @dev Only the owner may call.\n    function issueOwnerGrant(address grantee, uint256 prpAmount) external;\n\n    /// @notice Burn unused grants for the msg.sender in the specified PRP amount\n    function burnGrant(uint256 prpAmount) external;\n\n    /// @notice Account for redemption of grants in the given amount for the given grantee\n    /// @dev Only the account returned by `grantProcessor()` may call\n    function redeemGrant(address grantee, uint256 prpAmount) external;\n\n    /// @notice PRP grant issued\n    event PrpGrantIssued(\n        bytes4 indexed grantType,\n        address grantee,\n        uint256 prpAmount\n    );\n\n    /// @notice PRP grant redeemed (used)\n    event PrpGrantRedeemed(address grantee, uint256 prpAmount);\n\n    /// @notice PRP grant burnt\n    event PrpGrantBurnt(address grantee, uint256 prpAmount);\n\n    /// @notice New grant type added\n    event PrpGrantEnabled(address curator, bytes4 grantType, uint256 prpAmount);\n\n    /// @notice Existing grant type disabled\n    event PrpGrantDisabled(address curator, bytes4 grantType);\n}\n"
    },
    "contracts/protocol/interfaces/IZAssetsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { ZAsset } from \"../../common/Types.sol\";\n\ninterface IZAssetsRegistry {\n    /// @dev declared as view rather than pure to allow for protocol changes\n    function getZAssetId(address token, uint256 subId)\n        external\n        view\n        returns (uint160);\n\n    function getZAssetAndIds(address token, uint256 subId)\n        external\n        view\n        returns (\n            uint160 zAssetId,\n            uint256 _tokenId,\n            uint160 zAssetRecId,\n            ZAsset memory asset\n        );\n\n    function getZAsset(uint160 zAssetRecId)\n        external\n        view\n        returns (ZAsset memory asset);\n\n    function isZAssetWhitelisted(uint160 zAssetRecId)\n        external\n        view\n        returns (bool);\n\n    event AssetAdded(uint160 indexed zAssetRecId, ZAsset asset);\n    event AssetStatusChanged(\n        uint160 indexed zAssetRecId,\n        uint8 newStatus,\n        uint8 oldStatus\n    );\n}\n"
    },
    "contracts/protocol/pantherPool/AmountConvertor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { MAX_EXT_AMOUNT, MAX_IN_CIRCUIT_AMOUNT } from \"../../common/Constants.sol\";\nimport { ERR_TOO_LARGE_AMOUNT, ERR_TOO_LARGE_SCALED_AMOUNT } from \"../errMsgs/PantherPoolErrMsgs.sol\";\n\n/**\n * @title AmountConvertor\n * @author Pantherprotocol Contributors\n * @notice Methods for scaling amounts for computations within/outside the\n * Panther Protocol Multi-Asset Shielded Pool (aka \"MASP\")\n */\nabstract contract AmountConvertor {\n    // \"Scaled amounts\" - amounts ZK-circuits of the MASP operate with\n    // \"Unscaled amounts\" - amounts token contracts operate with\n    // Scaling is relevant for fungible tokens only - for ERC-721/ERC-1155\n    // tokens, scaled and unscaled amounts MUST be equal. For some ERC-20\n    // tokens, the \"scaling factor\" MAY be 1:1, i.e. scaled and unscaled\n    // amounts are equal.\n\n    // Conversion from the unscaled amount (aka amount) to the scaled one.\n    // Returns the scaled amount and the reminder.\n    function _scaleAmount(uint256 amount, uint8 scale)\n        internal\n        pure\n        returns (uint64 scaledAmount, uint256 change)\n    {\n        uint256 _scaledAmount;\n        if (scale == 0) {\n            // No scaling and no change for zero `scale`\n            _scaledAmount = amount;\n            change = 0;\n        } else {\n            unchecked {\n                uint256 factor = _getScalingFactor(scale);\n                // divider can't be zero, loss of precision assumed\n                // slither-disable-next-line divide-before-multiply\n                _scaledAmount = amount / factor;\n                // `restoredAmount` can not exceed the `amount`\n                uint256 restoredAmount = _scaledAmount * factor;\n                change = amount - restoredAmount;\n            }\n        }\n        scaledAmount = _sanitizeScaledAmount(_scaledAmount);\n    }\n\n    // Conversion from the scaled amount to unscaled one.\n    // Returns the unscaled amount.\n    function _unscaleAmount(uint64 scaledAmount, uint8 scale)\n        internal\n        pure\n        returns (uint96)\n    {\n        uint256 amount = scale == 0\n            ? scaledAmount // no scaling\n            : uint256(scaledAmount) * _getScalingFactor(scale);\n        return _sanitizeAmount(amount);\n    }\n\n    function _sanitizeAmount(uint256 amount) internal pure returns (uint96) {\n        require(amount < MAX_EXT_AMOUNT, ERR_TOO_LARGE_AMOUNT);\n        return uint96(amount);\n    }\n\n    function _sanitizeScaledAmount(uint256 scaledAmount)\n        internal\n        pure\n        returns (uint64)\n    {\n        require(\n            scaledAmount < MAX_IN_CIRCUIT_AMOUNT,\n            ERR_TOO_LARGE_SCALED_AMOUNT\n        );\n        return uint64(scaledAmount);\n    }\n\n    /// Private functions follow\n\n    // Note: implementation accepts 0..255 values for nonZeroScale\n    // It is responsibility of the caller check it is indeed less than 255 since 10^255 overflows uint256\n    // This overflow check not implemented here since caller will implement it in upper level\n    function _getScalingFactor(uint8 nonZeroScale)\n        private\n        pure\n        returns (uint256)\n    {\n        return 10**nonZeroScale;\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/CommitmentGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT4 } from \"../crypto/Poseidon.sol\";\n\nimport { ERR_TOO_LARGE_PUBKEY } from \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\n\nabstract contract CommitmentGenerator {\n    /// Generate UTXOs, these UTXOs will be used later\n    /// @param pubSpendingKeyX Public Spending Key for every UTXO - 256 bit - used in circom\n    /// @param pubSpendingKeyY Public Spending Key for every UTXO - 256 bit - used in circom\n    /// @param scaledAmount 64 bit size - used in circom\n    /// @param zAssetId 160 bit size - used in circom\n    /// @param creationTime 32 bit size - used in circom\n    function generateCommitment(\n        // slither-disable-next-line similar-names\n        uint256 pubSpendingKeyX,\n        // slither-disable-next-line similar-names\n        uint256 pubSpendingKeyY,\n        uint64 scaledAmount,\n        uint160 zAssetId,\n        uint32 creationTime\n    ) internal pure returns (bytes32 commitment) {\n        require(\n            pubSpendingKeyX <= FIELD_SIZE && pubSpendingKeyY <= FIELD_SIZE,\n            ERR_TOO_LARGE_PUBKEY\n        );\n        // Being 160 bits and less, other input params can't exceed FIELD_SIZE\n        commitment = PoseidonT4.poseidon(\n            [\n                bytes32(pubSpendingKeyX),\n                bytes32(pubSpendingKeyY),\n                bytes32(\n                    (uint256(scaledAmount) << 192) |\n                        (uint256(zAssetId) << 32) |\n                        uint256(creationTime)\n                )\n            ]\n        );\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/CommitmentsTrees.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../triadTree/TriadIncrementalMerkleTrees.sol\";\nimport { OUT_MAX_UTXOs } from \"../../common/Constants.sol\";\nimport { ERR_TOO_LARGE_COMMITMENTS } from \"../errMsgs/PantherPoolErrMsgs.sol\";\n\n/**\n * @title CommitmentsTrees\n * @author Pantherprotocol Contributors\n * @notice Incremental Merkle trees of commitments for the `PantherPool` contract\n */\nabstract contract CommitmentsTrees is TriadIncrementalMerkleTrees {\n    /**\n     * @dev Emitted on a new batch of Commitments\n     * @param leftLeafId The `leafId` of the first leaf in the batch\n     * @dev `leafId = leftLeafId + 1` for the 2nd leaf (`leftLeafId + 2` for the 3rd leaf)\n     * @param commitments Commitments hashes\n     * @param utxoData opening values (encrypted and public) for UTXOs\n     */\n    event NewCommitments(\n        uint256 indexed leftLeafId,\n        uint256 creationTime,\n        bytes32[OUT_MAX_UTXOs] commitments,\n        bytes utxoData\n    );\n\n    /**\n     * @notice Adds commitments to merkle tree(s) and emits events\n     * @param commitments Commitments (leaves hashes) to be inserted into merkle tree(s)\n     * @param msgTypes Types (i.e. formats) of the perUtxoData array elements\n     * @param perUtxoData opening values (encrypted and public) for every UTXO\n     * @return leftLeafId The `leafId` of the first leaf in the batch\n     */\n    function addAndEmitCommitments(\n        bytes32[OUT_MAX_UTXOs] memory commitments,\n        uint8 msgTypes,\n        bytes[OUT_MAX_UTXOs] memory perUtxoData,\n        uint256 timestamp\n    ) internal returns (uint256 leftLeafId) {\n        bytes memory utxoData = abi.encodePacked(msgTypes);\n\n        for (uint256 i = 0; i < OUT_MAX_UTXOs; i++) {\n            require(\n                uint256(commitments[i]) < FIELD_SIZE,\n                ERR_TOO_LARGE_COMMITMENTS\n            );\n            utxoData = bytes.concat(utxoData, perUtxoData[i]);\n        }\n\n        // Insert hashes into Merkle tree(s)\n        leftLeafId = insertBatch(commitments);\n\n        emit NewCommitments(leftLeafId, timestamp, commitments, utxoData);\n    }\n\n    // NOTE: The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // For compatibility on upgrades, decrease `__gap` if new variables added.\n    // slither-disable-next-line unused-state\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/pantherPool/MerkleProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT3, PoseidonT4 } from \"../crypto/Poseidon.sol\";\nimport \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport \"../triadTree/TriadIncrementalMerkleTrees.sol\";\n\nabstract contract MerkleProofVerifier {\n    // @dev Number of levels in a tree excluding the root level\n    // (also defined in scripts/generateTriadMerkleZeroesContracts.sh)\n    uint256 private constant TREE_DEPTH = 15;\n\n    //t |bH  bL| Subtree\n    //--|------|------------\n    //0 | 0  0 | hash(C,L,R)\n    //1 | 0  1 | hash(L,C,R)\n    //2 | 1  0 | hash(L,R,C)\n    //3 | 1  1 | Not allowed\n    //--|------|------------\n    // Current leaf index in triad is (C,L,R)\n    uint256 private constant iTRIAD_INDEX_LEFT = 0x0;\n    // Current leaf index in triad is (L,C,R)\n    uint256 private constant iTRIAD_INDEX_MIDDLE = 0x1;\n    // Current leaf index in triad is (L,R,C)\n    uint256 private constant iTRIAD_INDEX_RIGHT = 0x2;\n    // Forbidden triad value in tria is `11`\n    uint256 private constant iTRIAD_INDEX_FORBIDDEN = 0x3;\n\n    /// @param merkleRoot - verify checked to this hash\n    /// @param triadIndex - index inside triad = { 0, 1, 2 }\n    /// @param triadNodeIndex - index of triad hash ( c0,c1,c2 ) in the tree - Triad contract insures its is in range\n    /// @param leaf - commitment leaf value\n    /// @param pathElements - TREE_DEPTH + 1 elements - c1,c2 & path-elements\n    /// @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n    /// @dev defined by `root`. For this, a `proof` must be provided, containing\n    /// @dev sibling hashes on the branch from the leaf to the root of the tree.\n    function verifyMerkleProof(\n        bytes32 merkleRoot,\n        uint256 triadIndex,\n        uint256 triadNodeIndex,\n        bytes32 leaf,\n        bytes32[TREE_DEPTH + 1] calldata pathElements\n    ) internal pure {\n        // [0] - Assumed it is computed by the TriadIncrementalMerkleTrees\n        //       using modulo operation, so no need to check lower range\n        //require(iTRIAD_INDEX_LEFT <= triadIndex, ERR_TRIAD_INDEX_MIN_VALUE);\n        require(triadIndex < iTRIAD_INDEX_FORBIDDEN, ERR_TRIAD_INDEX_MAX_VALUE);\n\n        // [1] - Compute zero level hash\n        // variable will be initialized inside the 'if' bellow\n        // slither-disable-next-line uninitialized-local\n        bytes32 nodeHash;\n        // NOTE: no else-case needed since this code executed after require at step [0]\n        if (triadIndex == iTRIAD_INDEX_LEFT) {\n            nodeHash = PoseidonT4.poseidon(\n                [leaf, pathElements[0], pathElements[1]]\n            );\n        } else if (triadIndex == iTRIAD_INDEX_MIDDLE) {\n            nodeHash = PoseidonT4.poseidon(\n                [pathElements[0], leaf, pathElements[1]]\n            );\n        } else if (triadIndex == iTRIAD_INDEX_RIGHT) {\n            nodeHash = PoseidonT4.poseidon(\n                [pathElements[0], pathElements[1], leaf]\n            );\n        }\n\n        // [2] - Compute root\n        for (uint256 level = 2; level < pathElements.length; level++) {\n            bool isLeftNode;\n            unchecked {\n                // triadNodeIndex is actually a path to triad-node in merkle-tree\n                // each LSB bit of this number is left or right path\n                // it means for example: path = b111 , zero leaf will be from right size of hash\n                // and path element[2] will be from right side of hash, all other path elements [3,4] will be from\n                // left side of the next hashes till root.\n                isLeftNode = ((triadNodeIndex & (0x1 << (level - 2))) == 0);\n            }\n            if (isLeftNode) {\n                // computed node from left side\n                // Hash(left = nodeHash, right = pathElement)\n                nodeHash = PoseidonT3.poseidon([nodeHash, pathElements[level]]);\n            } else {\n                // computed node from right side\n                // Hash(left = pathElement, right = nodeHash)\n                nodeHash = PoseidonT3.poseidon([pathElements[level], nodeHash]);\n            }\n        }\n        // [3] - revert if verification fails\n        require(merkleRoot == nodeHash, ERR_MERKLE_PROOF_VERIFICATION_FAILED);\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/NullifierGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT3 } from \"../crypto/Poseidon.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\nimport { ERR_TOO_LARGE_LEAFID, ERR_TOO_LARGE_PRIVKEY } from \"../errMsgs/PantherPoolErrMsgs.sol\";\n\nabstract contract NullifierGenerator {\n    function generateNullifier(uint256 privSpendingKey, uint256 leafId)\n        internal\n        pure\n        returns (bytes32 nullifier)\n    {\n        require(privSpendingKey < FIELD_SIZE, ERR_TOO_LARGE_PRIVKEY);\n        require(leafId < FIELD_SIZE, ERR_TOO_LARGE_LEAFID);\n        nullifier = PoseidonT3.poseidon(\n            [bytes32(privSpendingKey), bytes32(leafId)]\n        );\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/PubKeyGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { G1Point } from \"../../common/Types.sol\";\nimport { ERR_TOO_LARGE_PRIVKEY } from \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\nimport \"../crypto/BabyJubJub.sol\";\n\nabstract contract PubKeyGenerator {\n    function generatePubSpendingKey(uint256 privKey)\n        internal\n        view\n        returns (G1Point memory pubKey)\n    {\n        // [0] - Require\n        require(privKey < FIELD_SIZE, ERR_TOO_LARGE_PRIVKEY);\n        // [1] - Generate public key\n        G1Point memory base8 = G1Point({\n            x: BabyJubJub.BASE8_X,\n            y: BabyJubJub.BASE8_Y\n        });\n        pubKey = BabyJubJub.mulPointEscalar(base8, privKey);\n    }\n}\n"
    },
    "contracts/protocol/crypto/Poseidon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// This is a stub to keep solc happy; the actual code is generated\n// using poseidon_gencontract.js from circomlibjs.\n\nlibrary PoseidonT3 {\n    function poseidon(bytes32[2] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT4 {\n    function poseidon(bytes32[3] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT6 {\n    function poseidon(bytes32[5] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n"
    },
    "contracts/protocol/crypto/SnarkConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\npragma solidity ^0.8.16;\n\n// @dev Order of alt_bn128 and the field prime of Baby Jubjub and Poseidon hash\nuint256 constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n// @dev Field prime of alt_bn128\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n"
    },
    "contracts/protocol/triadTree/TriadIncrementalMerkleTrees.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./Hasher.sol\";\nimport \"./TriadMerkleZeros.sol\";\nimport { ERR_ZERO_ROOT } from \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport \"../interfaces/IRootsHistory.sol\";\n\n/**\n * @title TriadIncrementalMerkleTrees\n * @author Pantherprotocol Contributors\n * @notice Incremental Merkle trees with batch insertion of 3 leaves at once\n * @dev Refer to {TriadMerkleZeros} for comments on \"triad trees\" used\n * Inspired by MACI project\n * https://github.com/appliedzkp/maci/blob/master/contracts/sol/IncrementalMerkleTree.sol\n */\ncontract TriadIncrementalMerkleTrees is\n    TriadMerkleZeros,\n    Hasher,\n    IRootsHistory\n{\n    /**\n     * @dev {treeId} is a consecutive number of trees, starting from 0.\n     * @dev {leafId} of a leaf is a \"modified\" number of leaves inserted in all\n     * tries before this leaf. It is unique across all trees, starts from 0 for\n     * the 1st leaf of the 1st tree, and constantly increments like this:\n     * 0,1,2,  4,5,6,  8,9,10,  12,13,14 ... (i.e. every 4th number is skipped)\n     * See comments to {TriadMerkleZeros}.\n     */\n\n    // `leafId` of the next leaf to insert\n    // !!! NEVER access it directly from child contracts: `internal` to ease testing only\n    uint256 internal _nextLeafId;\n\n    // Right-most elements (hashes) in the current tree per level\n    // level index => hash\n    mapping(uint256 => bytes32) private _filledSubtrees;\n\n    /// @notice Roots of fully populated trees\n    /// @dev treeId => root\n    mapping(uint256 => bytes32) public finalRoots;\n\n    // Recent roots of trees seen\n    // cacheIndex => root ^ treeId\n    mapping(uint256 => uint256) private _cachedRoots;\n\n    // @dev Root permanently added to the `finalRoots`\n    event AnchoredRoot(uint256 indexed treeId, bytes32 root);\n\n    // @dev Root temporarily saved in the `_cachedRoots`\n    event CachedRoot(uint256 indexed treeId, bytes32 root);\n\n    // NOTE: No `constructor` (initialization) function needed\n\n    // solhint-disable const-name-snakecase\n\n    // Max number of latest roots to cache (must be a power of 2)\n    uint256 internal constant CACHED_ROOTS_NUM = 256;\n\n    // Number of leaves in a modified triad used for leaf ID calculation\n    uint256 private constant iTRIAD_SIZE = 4;\n    // The number of leaves in a tree used for leaf ID calculation\n    uint256 private constant iLEAVES_NUM = 2**(TREE_DEPTH - 1) * iTRIAD_SIZE;\n\n    // Bitmasks and numbers of bits for \"cheaper\" arithmetics\n    uint256 private constant iTRIAD_SIZE_MASK = iTRIAD_SIZE - 1;\n    uint256 private constant iTRIAD_SIZE_BITS = 2;\n    uint256 private constant iLEAVES_NUM_MASK = iLEAVES_NUM - 1;\n    uint256 private constant iLEAVES_NUM_BITS =\n        TREE_DEPTH - 1 + iTRIAD_SIZE_BITS;\n    uint256 private constant CACHE_SIZE_MASK =\n        CACHED_ROOTS_NUM * iTRIAD_SIZE - 1;\n\n    // solhint-enable const-name-snakecase\n\n    /**\n     * @notice Returns the number of leaves inserted in all trees so far\n     */\n    function leavesNum() external view returns (uint256) {\n        return _nextLeafId2LeavesNum(_nextLeafId);\n    }\n\n    /**\n     * @notice Returns `treeId` of the current tree\n     */\n    function curTree() external view returns (uint256) {\n        return getTreeId(_nextLeafId);\n    }\n\n    /**\n     * @notice Returns `treeId` of the given leaf's tree\n     */\n    function getTreeId(uint256 leafId) public pure returns (uint256) {\n        // equivalent to `leafId / iLEAVES_NUM`\n        return leafId >> iLEAVES_NUM_BITS;\n    }\n\n    /**\n     * @notice Returns `leafIndex` (index in the tree) of the given leaf\n     */\n    function getLeafIndex(uint256 leafId) public pure returns (uint256) {\n        unchecked {\n            // equiv to `leafId % LEAVES_NUM`\n            uint256 iIndex = leafId & iLEAVES_NUM_MASK; // throws away tree-id bits\n            uint256 fullTriadsNum = (iIndex + 1) >> iTRIAD_SIZE_BITS; // computes index of triad node in the tree\n            return iIndex - fullTriadsNum; // start index of first leaf in the triad\n        }\n    }\n\n    /**\n     * @notice Returns the root of the current tree and its index in cache\n     */\n    function curRoot()\n        external\n        view\n        returns (bytes32 root, uint256 cacheIndex)\n    {\n        // Return zero root and index if the current tree is empty\n        uint256 nextLeafId = _nextLeafId;\n        if (_isEmptyTree(nextLeafId)) return (ZERO_ROOT, 0);\n\n        // Return cached values otherwise\n        uint256 treeId = getTreeId(nextLeafId);\n        cacheIndex = _nextLeafId2CacheIndex(nextLeafId);\n        uint256 v = _cachedRoots[cacheIndex];\n        root = bytes32(v ^ treeId);\n    }\n\n    /// @inheritdoc IRootsHistory\n    function isKnownRoot(\n        uint256 treeId,\n        bytes32 root,\n        uint256 cacheIndexHint\n    ) public view override returns (bool) {\n        require(root != 0, ERR_ZERO_ROOT);\n\n        // if hint provided, use hint\n        if (cacheIndexHint != 0)\n            return _isCorrectCachedRoot(treeId, root, cacheIndexHint);\n\n        // then, check the history\n        if (finalRoots[treeId] == root) return true;\n\n        // finally, look in cache, starting from the current root\n        uint256 leafId = _nextLeafId;\n        unchecked {\n            uint256 i = CACHED_ROOTS_NUM;\n            while ((leafId >= iTRIAD_SIZE) && (i != 0)) {\n                i -= 1;\n                // Skip the last triad in a tree (i.e. the full tree root)\n                if (leafId & iLEAVES_NUM_MASK == 0) continue;\n                uint256 cacheIndex = _nextLeafId2CacheIndex(leafId);\n                if (_isCorrectCachedRoot(treeId, root, cacheIndex)) return true;\n                leafId -= iTRIAD_SIZE;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Inserts 3 leaves into the current tree, or a new one, if that's full\n     * @param leaves The 3 leaves to insert (must be less than SNARK_SCALAR_FIELD)\n     * @return leftLeafId The `leafId` of the first leaf from 3 inserted\n     */\n    function insertBatch(bytes32[TRIAD_SIZE] memory leaves)\n        internal\n        returns (uint256 leftLeafId)\n    {\n        leftLeafId = _nextLeafId;\n\n        // here the variable is intentionally declared only ...\n        // slither-disable-next-line uninitialized-local\n        bytes32[TREE_DEPTH] memory zeros;\n        // ... and initialized in this call\n        populateZeros(zeros);\n\n        // index of a \"current\" node (0 for the leftmost node/leaf of a level)\n        uint256 nodeIndex;\n        // hash (value) of a \"current\" node\n        bytes32 nodeHash;\n        // index of a \"current\" level (0 for leaves, increments toward root)\n        uint256 level;\n\n        // subtree from 3 leaves being inserted on `level = 0`\n        nodeHash = hash(leaves[0], leaves[1], leaves[2]);\n        // ... to be placed under this index on `level = 1`\n        // (equivalent to `(leftLeafId % iLEAVES_NUM) / iTRIAD_SIZE`)\n        nodeIndex = (leftLeafId & iLEAVES_NUM_MASK) >> iTRIAD_SIZE_BITS;\n\n        bytes32 left;\n        bytes32 right;\n        for (level = 1; level < TREE_DEPTH; level++) {\n            // if `nodeIndex` is, say, 25, over the iterations it will be:\n            // 25, 12, 6, 3, 1, 0, 0 ...\n\n            if (nodeIndex % 2 == 0) {\n                left = nodeHash;\n                right = zeros[level];\n                _filledSubtrees[level] = nodeHash;\n            } else {\n                // for a new tree, \"than\" block always run before \"else\" block\n                // so `_filledSubtrees[level]` gets updated before its use\n                left = _filledSubtrees[level];\n                right = nodeHash;\n            }\n\n            nodeHash = hash(left, right);\n\n            // equivalent to `nodeIndex /= 2`\n            nodeIndex >>= 1;\n        }\n\n        uint256 nextLeafId = leftLeafId + iTRIAD_SIZE;\n        _nextLeafId = nextLeafId;\n\n        uint256 treeId = getTreeId(leftLeafId);\n        if (_isFullTree(leftLeafId)) {\n            // Switch to a new tree\n            // Ignore `_filledSubtrees` old values as they are never re-used\n            finalRoots[treeId] = nodeHash;\n            emit AnchoredRoot(treeId, nodeHash);\n        } else {\n            uint256 cacheIndex = _nextLeafId2CacheIndex(nextLeafId);\n            _cachedRoots[cacheIndex] = uint256(nodeHash) ^ treeId;\n            emit CachedRoot(treeId, nodeHash);\n        }\n    }\n\n    /// private functions follow (some of them made `internal` to ease testing)\n    function _isFullTree(uint256 leftLeafId) internal pure returns (bool) {\n        unchecked {\n            return\n                (iLEAVES_NUM - (leftLeafId & iLEAVES_NUM_MASK)) <= iTRIAD_SIZE;\n        }\n    }\n\n    function _isEmptyTree(uint256 nextLeafId) internal pure returns (bool) {\n        return (nextLeafId & iLEAVES_NUM_MASK) == 0;\n    }\n\n    function _nextLeafId2LeavesNum(\n        uint256 nextLeafId // declared as `internal` to facilitate testing\n    ) internal pure returns (uint256) {\n        // equiv to `nextLeafId / iTRIAD_SIZE * TRIAD_SIZE + nextLeafId % iTRIAD_SIZE`\n        unchecked {\n            return\n                (nextLeafId >> iTRIAD_SIZE_BITS) *\n                TRIAD_SIZE +\n                (nextLeafId & iTRIAD_SIZE_MASK);\n        }\n    }\n\n    // Returns `triadIndex` index in the triad-node of the given leaf = { 0, 1, 2 }\n    function _getTriadIndex(uint256 leafId) internal pure returns (uint256) {\n        return getLeafIndex(leafId) % TRIAD_SIZE;\n    }\n\n    // Returns `triadNodeIndex` index of the triad-node of the given leaf\n    // This index is the path to this node - used by anyone who needs the path\n    function _getTriadNodeIndex(uint256 leafId)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            // equiv to `leafId % LEAVES_NUM`\n            uint256 iIndex = leafId & iLEAVES_NUM_MASK; // throws away tree-id bits\n            uint256 fullTriadsNum = (iIndex + 1) >> iTRIAD_SIZE_BITS; // computes index of triad node in the tree\n            return fullTriadsNum;\n        }\n    }\n\n    // nextLeafId must be even\n    function _nextLeafId2CacheIndex(uint256 nextLeafId)\n        private\n        pure\n        returns (uint256)\n    {\n        // equiv to `nextLeafId % (CACHED_ROOTS_NUM * iTRIAD_SIZE) + 1`\n        return (nextLeafId & CACHE_SIZE_MASK) | 1;\n    }\n\n    function _isCorrectCachedRoot(\n        uint256 treeId,\n        bytes32 root,\n        uint256 cacheIndex\n    ) private view returns (bool) {\n        uint256 v = _cachedRoots[cacheIndex];\n        return v == (uint256(root) ^ treeId);\n    }\n\n    // NOTE: The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // For compatibility on upgrades, decrease `__gap` if new variables added.\n    // slither-disable-next-line unused-state\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/triadTree/Hasher.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT3, PoseidonT4 } from \"../crypto/Poseidon.sol\";\n\n/*\n * @dev Poseidon hash functions\n */\nabstract contract Hasher {\n    function hash(bytes32 left, bytes32 right) internal pure returns (bytes32) {\n        bytes32[2] memory input;\n        input[0] = left;\n        input[1] = right;\n        return PoseidonT3.poseidon(input);\n    }\n\n    function hash(\n        bytes32 left,\n        bytes32 mid,\n        bytes32 right\n    ) internal pure returns (bytes32) {\n        bytes32[3] memory input;\n        input[0] = left;\n        input[1] = mid;\n        input[2] = right;\n        return PoseidonT4.poseidon(input);\n    }\n}\n"
    },
    "contracts/protocol/triadTree/TriadMerkleZeros.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\n\n// Content is autogenerated by `lib/triadMerkleZerosContractGenerator.ts`\n\n/**\n * @dev The \"triad binary tree\" is a modified Merkle (full) binary tree with:\n * - every node, from the root upto the level preceding leaves, excluding\n * that level, has 2 child nodes (i.e. this subtree is a full binary tree);\n * - every node of the layer preceding leaves has 3 child nodes (3 leaves).\n * Example:\n * [4]                                       0\n *                                           |\n * [3]                        0--------------------------------1\n *                            |                                |\n * [2]                0---------------1                 2--------------3\n *                    |               |                 |              |\n * [1]            0-------1       2-------3        4-------5       6-------7\n *               /|\\     /|\\     /|\\     /|\\      /|\\     /|\\     /|\\     /|\\\n * [0] index:   0..2    3..5    6..8    9...11  12..14  15..17  18..20  21..24\n *\n *   leaf ID:   0..2    4..6    8..10   12..14  16..18  20..23  24..27  28..30\n *\n * - Number in [] is the \"level index\" that starts from 0 for the leaves level.\n * - Numbers in node/leaf positions are \"node/leaf indices\" which starts from 0\n *   for the leftmost node/leaf of every level.\n * - Numbers bellow leaves are IDs of leaves.\n *\n * Arithmetic operations with multiples of 2 (i.e. shifting) is \"cheaper\" than\n * operations with multiples of 3 (both on-chain and in zk-circuits).\n * Therefore, IDs of leaves (but NOT hashes of nodes) are calculated as if the\n * tree would have 4 (not 3) leaves in branches, with every 4th leaf skipped.\n * In other words, there are no leaves with IDs 3, 7, 11, 15, 19...\n */\n\n// @notice The \"triad binary tree\" populated with zero leaf values\nabstract contract TriadMerkleZeros {\n    // solhint-disable var-name-mixedcase\n\n    // @dev Number of levels in a tree excluding the root level\n    // (also defined in scripts/generateTriadMerkleZeroesContracts.sh)\n    uint256 internal constant TREE_DEPTH = 15;\n\n    // Number of leaves in a branch with the root on the level 1\n    uint256 internal constant TRIAD_SIZE = 3;\n\n    // @dev Leaf zero value (`keccak256(\"Pantherprotocol\")%FIELD_SIZE`)\n    bytes32 internal constant ZERO_VALUE =\n        bytes32(\n            uint256(\n                0x667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d\n            )\n        );\n\n    // Merkle root of a tree that contains zeros only\n    bytes32 internal constant ZERO_ROOT =\n        bytes32(\n            uint256(\n                0x20fc043586a9fcb416cdf2a3bc8a995f8f815d43f1046a20d1c588cf20482a55\n            )\n        );\n\n    // solhint-enable var-name-mixedcase\n\n    function populateZeros(bytes32[TREE_DEPTH] memory zeros) internal pure {\n        zeros[0] = bytes32(\n            uint256(\n                0x667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d\n            )\n        );\n        zeros[1] = bytes32(\n            uint256(\n                0x1be18cd72ac1586de27dd60eba90654bd54383004991951bccb0f6bad02c67f6\n            )\n        );\n        zeros[2] = bytes32(\n            uint256(\n                0x7677e6102f0acf343edde864f79ef7652faa5a66d575b8b60bb826a4aa517e6\n            )\n        );\n        zeros[3] = bytes32(\n            uint256(\n                0x28a85866ab97bd65cc94b0d1f5c5986481f8a0d65bdd5c1e562659eebb13cf63\n            )\n        );\n        zeros[4] = bytes32(\n            uint256(\n                0x87321a66ea3af7780128ea1995d7fc6ec44a96a1b2d85d3021208cede68c15c\n            )\n        );\n        zeros[5] = bytes32(\n            uint256(\n                0x233b4e488f0aaf5faef4fc8ea4fefeadb6934eb882bc33b9df782fd1d83b41a0\n            )\n        );\n        zeros[6] = bytes32(\n            uint256(\n                0x1a0cefcf0c592da6426717d3718408c61af1d0a9492887f3faecefcba1a0a309\n            )\n        );\n        zeros[7] = bytes32(\n            uint256(\n                0x2cdf963150b321923dd07b2b52659aceb529516a537dfebe24106881dd974293\n            )\n        );\n        zeros[8] = bytes32(\n            uint256(\n                0x93a186bf9ec2cc874ceab26409d581579e1a431ecb6987d428777ceedfa15c4\n            )\n        );\n        zeros[9] = bytes32(\n            uint256(\n                0xcbfc07131ef4197a4b4e60153d43381520ec9ab4c9c3ed34d88883a881a4e07\n            )\n        );\n        zeros[10] = bytes32(\n            uint256(\n                0x17b31de43ba4c687cf950ad00dfbe33df40047e79245b50bd1d9f87e622bf2af\n            )\n        );\n        zeros[11] = bytes32(\n            uint256(\n                0x2f3328354bceaf5882a8cc88053e0dd0ae594009a4e84e9e75a4fefe8604a602\n            )\n        );\n        zeros[12] = bytes32(\n            uint256(\n                0x2b2e8defd4dad2404c6874918925fc1192123f45df0ee3e04b6c16ff22ca1cfd\n            )\n        );\n        zeros[13] = bytes32(\n            uint256(\n                0x1cbdc4065aa4137da01d64a090706267d65f425ea5e815673516d29d9aa14d38\n            )\n        );\n        zeros[14] = bytes32(\n            uint256(\n                0x13ca69f9fde4ece39e395bb55dd41ed7dd9dfaa26671e26bd9fd6f4f635fc872\n            )\n        );\n    }\n}\n"
    },
    "contracts/protocol/interfaces/IRootsHistory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface IRootsHistory {\n    /// @notice Returns `true` if the given root of the given tree is known\n    /// @param cacheIndexHint Index of the root in the cache, ignored if 0\n    function isKnownRoot(\n        uint256 treeId,\n        bytes32 root,\n        uint256 cacheIndexHint\n    ) external view returns (bool);\n}\n"
    },
    "contracts/protocol/crypto/BabyJubJub.sol": {
      "content": "// SPDX-License-Identifier: GPL\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// Implementer name - yondonfu\n// Link to the implementation - https://github.com/yondonfu/sol-baby-jubjub/blob/master/contracts/CurveBabyJubJub.sol\npragma solidity ^0.8.16;\nimport \"../../common/Types.sol\";\n\nlibrary BabyJubJub {\n    // Curve parameters\n    // E: 168700x^2 + y^2 = 1 + 168696x^2y^2\n    // A = 168700\n    uint256 public constant A = 0x292FC;\n    // D = 168696\n    uint256 public constant D = 0x292F8;\n    // Prime Q = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n    // slither-disable-next-line too-many-digits\n    uint256 public constant Q =\n        0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001;\n\n    // @dev Base point generates the subgroup of points P of Baby Jubjub satisfying l * P = O.\n    // That is, it generates the set of points of order l and origin O.\n    // slither-disable-next-line too-many-digits\n    uint256 public constant BASE8_X =\n        5299619240641551281634865583518297030282874472190772894086521144482721001553;\n    // slither-disable-next-line too-many-digits\n    uint256 public constant BASE8_Y =\n        16950150798460657717958625567821834550301663161624707787222815936182638968203;\n\n    /**\n     * @dev Add 2 points on baby jubjub curve\n     * Formulae for adding 2 points on a twisted Edwards curve:\n     * x3 = (x1y2 + y1x2) / (1 + dx1x2y1y2)\n     * y3 = (y1y2 - ax1x2) / (1 - dx1x2y1y2)\n     */\n    function pointAdd(G1Point memory g1, G1Point memory g2)\n        internal\n        view\n        returns (G1Point memory)\n    {\n        uint256 x3 = 0;\n        uint256 y3 = 0;\n        if (g1.x == 0 && g1.y == 0) {\n            return G1Point(x3, y3);\n        }\n\n        if (g2.x == 0 && g1.y == 0) {\n            return G1Point(x3, y3);\n        }\n\n        uint256 x1x2 = mulmod(g1.x, g2.x, Q);\n        uint256 y1y2 = mulmod(g1.y, g2.y, Q);\n        uint256 dx1x2y1y2 = mulmod(D, mulmod(x1x2, y1y2, Q), Q);\n        uint256 x3Num = addmod(mulmod(g1.x, g2.y, Q), mulmod(g1.y, g2.x, Q), Q);\n        uint256 y3Num = submod(y1y2, mulmod(A, x1x2, Q), Q);\n\n        x3 = mulmod(x3Num, inverse(addmod(1, dx1x2y1y2, Q)), Q);\n        y3 = mulmod(y3Num, inverse(submod(1, dx1x2y1y2, Q)), Q);\n        return G1Point(x3, y3);\n    }\n\n    /**\n     * @dev Perform modular subtraction\n     */\n    function submod(\n        uint256 _a,\n        uint256 _b,\n        uint256 _mod\n    ) internal pure returns (uint256) {\n        uint256 aNN = _a;\n\n        if (_a <= _b) {\n            aNN += _mod;\n        }\n\n        return addmod(aNN - _b, 0, _mod);\n    }\n\n    /**\n     * @dev Compute modular inverse of a number\n     */\n    function inverse(uint256 _a) internal view returns (uint256) {\n        // We can use Euler's theorem instead of the extended Euclidean algorithm\n        // Since m = Q and Q is prime we have: a^-1 = a^(m - 2) (mod m)\n        return expmod(_a, Q - 2, Q);\n    }\n\n    /**\n     * @dev Helper function to call the bigModExp precompile\n     */\n    function expmod(\n        uint256 _b,\n        uint256 _e,\n        uint256 _m\n    ) internal view returns (uint256 o) {\n        // solhint-disable no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            let memPtr := mload(0x40)\n            mstore(memPtr, 0x20) // Length of base _b\n            mstore(add(memPtr, 0x20), 0x20) // Length of exponent _e\n            mstore(add(memPtr, 0x40), 0x20) // Length of modulus _m\n            mstore(add(memPtr, 0x60), _b) // Base _b\n            mstore(add(memPtr, 0x80), _e) // Exponent _e\n            mstore(add(memPtr, 0xa0), _m) // Modulus _m\n\n            // The bigModExp precompile is at 0x05\n            let success := staticcall(gas(), 0x05, memPtr, 0xc0, memPtr, 0x20)\n            switch success\n            case 0 {\n                revert(0x0, 0x0)\n            }\n            default {\n                o := mload(memPtr)\n            }\n        }\n        // solhint-enable no-inline-assembly\n    }\n\n    function mulPointEscalar(G1Point memory point, uint256 scalar)\n        internal\n        view\n        returns (G1Point memory r)\n    {\n        r.x = 0;\n        r.y = 1;\n\n        uint256 rem = scalar;\n        G1Point memory exp = point;\n\n        while (rem != uint256(0)) {\n            if ((rem & 1) == 1) {\n                r = pointAdd(r, exp);\n            }\n            exp = pointAdd(exp, exp);\n            rem = rem >> 1;\n        }\n        r.x = r.x % Q;\n        r.y = r.y % Q;\n\n        return r;\n    }\n}\n"
    },
    "contracts/protocol/mocks/PantherPoolV0AndZAssetRegistryTester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../PantherPoolV0.sol\";\nimport \"./FakeVault.sol\";\nimport \"./MockPantherPoolV0.sol\";\nimport \"../ZAssetsRegistry.sol\";\n\ncontract PantherPoolV0AndZAssetRegistryTester is MockPantherPoolV0 {\n    address private registry;\n\n    constructor()\n        MockPantherPoolV0(\n            address(this),\n            // This mock is the owner of ZAssetsRegistry\n            registry = address(new ZAssetsRegistry(address(this))),\n            address(new FakeVault())\n        )\n    {\n        ZAsset memory z1;\n        z1.tokenType = ERC20_TOKEN_TYPE;\n        z1.version = 0;\n        z1.scale = 0;\n        z1.token = address(uint160(111));\n        z1.status = zASSET_ENABLED;\n        ZAssetsRegistry(registry).addZAsset(z1);\n\n        exitTime = safe32TimeNow() + 1;\n    }\n\n    function testConvert(uint256 n) external pure returns (bytes32) {\n        return bytes32(n);\n    }\n\n    function testGenerateDepositsExtended(\n        address[OUT_UTXOs] calldata tokens,\n        uint256[OUT_UTXOs] calldata extAmounts,\n        uint256[2] calldata pubKeys,\n        uint256[CIPHERTEXT1_WORDS] calldata secrets,\n        uint32 createdAt\n    ) external {\n        address[OUT_UTXOs] memory tokenss;\n        tokenss[0] = tokens[0];\n        tokenss[1] = tokens[1];\n        tokenss[2] = tokens[2];\n\n        uint256[OUT_UTXOs] memory subIds;\n        subIds[0] = 0;\n        subIds[1] = 0;\n        subIds[2] = 0;\n\n        G1Point[OUT_UTXOs] memory pubKeyss;\n        pubKeyss[0] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[1] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[2] = G1Point(pubKeys[0], pubKeys[1]);\n\n        uint256[CIPHERTEXT1_WORDS][OUT_UTXOs] memory secretss;\n        secretss[0][0] = secrets[0];\n        secretss[0][1] = secrets[1];\n        secretss[1][0] = secrets[0];\n        secretss[1][1] = secrets[1];\n        secretss[2][0] = secrets[0];\n        secretss[2][1] = secrets[1];\n\n        this.generateDeposits(\n            tokens,\n            subIds,\n            extAmounts,\n            pubKeyss,\n            secretss,\n            createdAt\n        );\n    }\n}\n"
    },
    "contracts/protocol/mocks/FakeVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { LockData } from \"../../common/Types.sol\";\nimport \"../interfaces/IVault.sol\";\n\ncontract FakeVault is IVault {\n    event DebugData(LockData data);\n\n    function lockAsset(LockData calldata data) external override {\n        emit DebugData(data);\n    }\n\n    function unlockAsset(LockData memory data) external override {\n        emit DebugData(data);\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockPantherPoolV0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../PantherPoolV0.sol\";\n\n// solhint-disable var-name-mixedcase\n// solhint-disable no-empty-blocks\n// solhint-disable func-name-mixedcase\n// solhint-disable event-name-camelcase\ncontract MockPantherPoolV0 is PantherPoolV0 {\n    constructor(\n        address _owner,\n        address assetRegistry,\n        address vault\n    ) PantherPoolV0(_owner, assetRegistry, vault) {}\n\n    event RESULT_processDepositedAsset(uint160 zAssetId, uint96 scaledAmount);\n\n    function internalProcessDepositedAsset(\n        address token,\n        uint256 subId,\n        uint256 extAmount\n    ) external {\n        (uint160 zAssetId, uint96 scaledAmount) = _processDepositedAsset(\n            token,\n            subId,\n            extAmount\n        );\n        emit RESULT_processDepositedAsset(zAssetId, scaledAmount);\n    }\n\n    function testGeneratePublicSpendingKey(uint256 privKey)\n        external\n        view\n        returns (uint256[2] memory xy)\n    {\n        G1Point memory p;\n        p = generatePubSpendingKey(privKey);\n        xy[0] = p.x;\n        xy[1] = p.y;\n    }\n\n    function testUpdateExitTimes(uint32 newExitTime, uint24 newExitDelay)\n        external\n    {\n        this.updateExitTimes(newExitTime, newExitDelay);\n    }\n\n    function testExit(\n        address token,\n        uint256 subId,\n        uint64 scaledAmount,\n        uint32 creationTime,\n        uint256 privSpendingKey,\n        uint256 leafId,\n        bytes32[TREE_DEPTH + 1] calldata pathElements,\n        bytes32 merkleRoot,\n        uint256 cacheIndexHint\n    ) external {\n        this.exit(\n            token,\n            subId,\n            scaledAmount,\n            creationTime,\n            privSpendingKey,\n            leafId,\n            pathElements,\n            merkleRoot,\n            cacheIndexHint\n        );\n    }\n\n    function testGenerateCommitments(\n        uint256 pubSpendingKeyX,\n        uint256 pubSpendingKeyY,\n        uint64 scaledAmount,\n        uint160 zAssetId,\n        uint32 creationTime\n    ) external pure returns (uint256) {\n        return\n            uint256(\n                generateCommitment(\n                    pubSpendingKeyX,\n                    pubSpendingKeyY,\n                    scaledAmount,\n                    zAssetId,\n                    creationTime\n                )\n            );\n    }\n}\n"
    },
    "contracts/protocol/ZAssetsRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport { ERC20_TOKEN_TYPE, zASSET_ENABLED, zASSET_UNKNOWN } from \"../common/Constants.sol\";\nimport \"./errMsgs/ZAssetsRegistryErrMsgs.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport { ZAsset } from \"../common/Types.sol\";\nimport \"./interfaces/IZAssetsRegistry.sol\";\n\n/**\n * @title ZAssetsRegistry\n * @author Pantherprotocol Contributors\n * @notice Registry and whitelist of assets (tokens) supported by the Panther\n * Protocol Multi-Asset Shielded Pool (aka \"MASP\")\n */\ncontract ZAssetsRegistry is ImmutableOwnable, IZAssetsRegistry {\n    /**\n    \"zAsset\" - abstraction of a token for representation in the MASP.\n    ZK-circuits \"treat\" each zAsset as a unique (independent) token.\n    `zAssetId` - ID of a zAsset.\n    Circuits \"know\" a token by its zAssetID rather than the token addresses or\n    its _tokenId/_id.\n    Each distinguishable token supported by the MASP must be represented by its\n    \"own\" zAsset. zAsset must never  \"represent\" two (or more) different tokens.\n    An ERC-721/ERC-1155 token, with its unique _tokenId/_id, must \"have\" its own\n    zAsset, different from zAssets of other tokens on the same contract.\n    An ERC-20 token should be represented by at least one zAsset (further\n    referred to as the \"default\" zAsset). A few other zAssets (aka \"alternative\"\n    zAssets) may exist for the same ERC-20 token, with each zAsset having a\n    different \"scaling factor\" (`ZAsset.scale`).\n\n    `ZAsset` - a record on the Registry with parameters of zAsset(s).\n    `zAssetRecId` - ID of a ZAsset record.\n    Not every zAsset has its \"own\" ZAsset record, but each ZAsset keeps params\n    of at least one zAsset. It groups all zAssets, which share the same token\n    contract and the \"scaling factor\".\n    There is just one ZAsset record for all zAssets representing tokens on an\n    ERC-721/1155 contract. Thus, for any such supported contract there must be\n    EXACTLY one ZAsset record on the Registry.\n    Every zAsset representing an ERC-20 token must have its own ZAsset record.\n    So, the Registry must have at LEAST one ZAsset (for the default zAsset) for\n    an ERC-20 contract. However, other ZAsset records (for alternative zAssets)\n    may exist for the same ERC-20 token.\n\n    `subId` - additional ID which, coupled with the token contract address, let\n    deterministically compute `zAssetId` and `zAssetRecId`.\n\n    This code is written with the following specs in mind:\n    - If at least one token on an ERC-721/ERC-1155 contract is whitelisted, any\n      token on the contract is implicitly whitelisted w/o further configuration\n    - Registry must have one ZAsset record only for all tokens of an ERC-721/\n      ERC-1155 contract\n    - ZAsset record of any zAsset, w/ exception of extremely rare cases, should\n      be obtained with just a single SLOAD\n    - Backward compatible upgrades should be able to implement ..\n    -- .. separate whitelists of zAssets allowed for deposits and withdrawals\n       (e.g. via extension of ZAsset.status)\n    -- .. blacklist for some tokens on a whitelisted ERC-721/ERC-1155 contract\n       (e.g. by extending ZAsset.tokenType and introducing a blacklist)\n    -- .. limits per a zAsset for max allowed amounts of deposits/withdrawals\n       (e.g. with \"alternative\" zAssets and re-defining ZAsset._unused)\n    */\n\n    uint8 private constant MAX_SCALE = 32; // min scale is 0\n    uint8 private constant NO_SCALING = 0;\n    uint256 private constant DEFAULT_VER = 0;\n\n    // Mapping from `zAssetRecId` to ZAsset (i.e. params of an zAsset)\n    mapping(uint160 => ZAsset) private _registry;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) ImmutableOwnable(_owner) {\n        // Proxy-friendly: no storage initialization\n    }\n\n    function getZAssetId(address token, uint256 subId)\n        public\n        pure\n        override\n        returns (uint160)\n    {\n        // Being uint160, it is surely less then the FIELD_SIZE\n        return\n            uint160(\n                uint256(\n                    keccak256(abi.encode(uint256(uint160(token)), subId))\n                ) >> 96\n            );\n    }\n\n    /// @notice Returns ZAsset record for the given record ID\n    function getZAsset(uint160 zAssetRecId)\n        external\n        view\n        override\n        returns (ZAsset memory asset)\n    {\n        asset = _registry[zAssetRecId];\n    }\n\n    /// @notice Returns zAsset IDs and ZAsset record for the given token\n    /// @param token Address of the token contract\n    /// @param subId Extra ID to identify zAsset (0 by default)\n    /// @dev For ERC-721/ERC-1155 token, `subId` is the _tokenId/_id. For  the\n    // \"default\" zAsset of an ERC-20 token it is 0. For an \"alternative\" zAsset\n    // it is the `defaultZAssetRecId XOR ver`, where `defaultZAssetRecId` is the\n    // `zAssetRecId` of the default zAsset for this token, and `ver` is a unique\n    // int in the range [1..31].\n    /// @return zAssetId\n    /// @return _tokenId ERC-721/1155 _tokenId/_id, if it's an NFT, or 0 for ERC-20\n    /// @return zAssetRecId ID of the ZAsset record\n    /// @return asset ZAsset record for the token\n    function getZAssetAndIds(address token, uint256 subId)\n        external\n        view\n        override\n        returns (\n            uint160 zAssetId,\n            uint256 _tokenId,\n            uint160 zAssetRecId,\n            ZAsset memory asset\n        )\n    {\n        require(token != address(0), ERR_ZERO_TOKEN_ADDRESS);\n\n        // Gas optimized based on assumptions:\n        // - most often, this code is called for the default zAsset of ERC-20\n        // - if `ver` is in [1..MAX_SCALE], likely it's an alternative zAsset\n        _tokenId = subId;\n        if (subId != 0) {\n            // Risk of zAssetRecId collision attack (see further) ignored since\n            // `subId` variant space is small (less than MAX_SCALE of ~5 bits).\n            // Therefore `require(asset.token == token)` omitted here.\n\n            // For an \"alternative\" zAsset, `subId` must be none-zero...\n            uint256 ver = uint256(uint160(token)) ^ subId;\n            // ... and `ver` must be in [1..MAX_SCALE]\n            if (ver < MAX_SCALE && ver != DEFAULT_VER) {\n                // Likely, it's the alternative zAsset w/ `zAssetRecId = subId`\n                asset = _registry[uint160(subId)];\n\n                if (asset.version == uint8(ver)) {\n                    // Surely, it's the alternative zAsset of the ERC-20 token\n                    // as `.version` must be 0 for NFTs and default zAssets.\n                    // As `.version != 0`, `.status` can't be zASSET_UNKNOWN.\n                    // Check `asset.tokenType == ERC20_TOKEN_TYPE` is skipped\n                    // as the code registering ZAssets is assumed to ensure it.\n                    zAssetId = getZAssetId(token, subId);\n                    zAssetRecId = uint160(subId);\n                    _tokenId = DEFAULT_VER;\n                    return (zAssetId, _tokenId, zAssetRecId, asset);\n                }\n            }\n        }\n        // The zAsset can't be an alternative zAsset of an ERC-20 token here.\n        // It's either an NFT (`subId` is _tokenId), or the default zAsset of\n        // an ERC-20 token (`subId` is 0). In both cases `asset.version == 0`.\n\n        zAssetRecId = uint160(token); // same as `uint160(token) ^ 0`\n        asset = _registry[zAssetRecId];\n        if (asset.status == zASSET_UNKNOWN) {\n            // Unknown token - return zero IDs, and empty ZAsset\n            return (0, 0, 0, asset);\n        }\n\n        require(\n            // `subId` of an ERC-20 token's default zAsset must be 0\n            (subId == 0 || asset.tokenType != ERC20_TOKEN_TYPE) &&\n                // zAssetReqId collision attack protection:\n                // attacker may vary token id of a fake NFT to make zAssetReqId\n                // (i.e. `token ^ subId`) equal to zAssetReqId of another token\n                asset.token == token,\n            ERR_ZERO_SUBID_EXPECTED\n        );\n        zAssetId = getZAssetId(token, _tokenId);\n        return (zAssetId, _tokenId, zAssetRecId, asset);\n    }\n\n    function isZAssetWhitelisted(uint160 zAssetRecId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        ZAsset memory asset = _registry[zAssetRecId];\n        return asset.status == zASSET_ENABLED;\n    }\n\n    /// @notice Register with the MASP a new asset with given params\n    /// @param asset Params of the asset (including its `ZAsset.status`)\n    /// @dev The \"owner\" may call only\n    function addZAsset(ZAsset memory asset) external onlyOwner {\n        require(asset.token != address(0), ERR_ZERO_TOKEN_ADDRESS);\n        require(asset.status != zASSET_UNKNOWN, ERR_WRONG_ASSET_STATUS);\n        require(\n            // ERC-20 zAsset only may be \"alternative\" ones\n            asset.version == 0 ||\n                (asset.tokenType == ERC20_TOKEN_TYPE &&\n                    asset.version < MAX_SCALE),\n            ERR_WRONG_ASSET_VER\n        );\n        _checkScaleIsInRange(asset);\n\n        // note, `x ^ 0 == x`\n        uint160 zAssetRecId = uint160(asset.token) ^ uint160(asset.version);\n\n        ZAsset memory existingAsset = _registry[zAssetRecId];\n        require(\n            existingAsset.status == zASSET_UNKNOWN,\n            ERR_ASSET_ALREADY_REGISTERED\n        );\n        _registry[zAssetRecId] = asset;\n        emit AssetAdded(zAssetRecId, asset);\n    }\n\n    /// @notice Updates the status of the existing asset\n    /// @param zAssetRecId ID of the ZAsset record\n    /// @param newStatus Status to be set\n    /// @dev The \"owner\" may call only\n    function changeZAssetStatus(uint160 zAssetRecId, uint8 newStatus)\n        external\n        onlyOwner\n    {\n        require(_registry[zAssetRecId].token != address(0), ERR_UNKNOWN_ASSET);\n        uint8 oldStatus = _registry[zAssetRecId].status;\n        // New status value restrictions relaxed to allow for protocol updates.\n        require(\n            newStatus != zASSET_UNKNOWN && oldStatus != newStatus,\n            ERR_WRONG_ASSET_STATUS\n        );\n        _registry[zAssetRecId].status = newStatus;\n        emit AssetStatusChanged(zAssetRecId, newStatus, oldStatus);\n    }\n\n    function _checkScaleIsInRange(ZAsset memory asset) private pure {\n        // Valid range for ERC-20 is [0..31]\n        // Valid range for ERC-721/ERC-1155 is 0\n        require(\n            (asset.scale == NO_SCALING ||\n                ((asset.scale < MAX_SCALE) &&\n                    (asset.tokenType == ERC20_TOKEN_TYPE))),\n            ERR_WRONG_ASSET_SCALE\n        );\n    }\n}\n"
    },
    "contracts/protocol/errMsgs/ZAssetsRegistryErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_ASSET_ALREADY_REGISTERED = \"AR:E1\";\nstring constant ERR_UNKNOWN_ASSET = \"AR:E2\";\nstring constant ERR_WRONG_ASSET_STATUS = \"AR:E3\";\nstring constant ERR_WRONG_ASSET_SCALE = \"AR:E4\";\nstring constant ERR_WRONG_ASSET_VER = \"AR:E5\";\nstring constant ERR_ZERO_SUBID_EXPECTED = \"AR:E6\";\nstring constant ERR_ZERO_TOKEN_ADDRESS = \"AR:E7\";\n"
    },
    "contracts/staking/mocks/FakePantherPoolV0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.16;\n\nimport { CIPHERTEXT1_WORDS, OUT_MAX_UTXOs, PATH_ELEMENTS_NUM } from \"../../common/Constants.sol\";\nimport { G1Point } from \"../../common/Types.sol\";\nimport \"../interfaces/IPantherPoolV0.sol\";\n\n/// @dev It simulates (but not precisely!!!) `IPantherPoolV0`. See an example bellow.\ncontract FakePantherPoolV0 is IPantherPoolV0 {\n    // solhint-disable var-name-mixedcase\n\n    // Snark field size\n    uint256 private constant FIELD_SIZE =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    // Leaf zero value (`keccak256(\"Pantherprotocol\")%FIELD_SIZE`)\n    bytes32 internal constant ZERO_VALUE =\n        bytes32(\n            uint256(\n                0x667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d\n            )\n        );\n\n    address public immutable override VAULT;\n    uint256 public immutable exitTime;\n\n    // solhint-enable var-name-mixedcase\n\n    uint256 public fakeLeavesNum;\n\n    mapping(bytes32 => bool) public isSpent;\n\n    constructor(address anyVaultAddress, uint256 _exitTime) {\n        VAULT = anyVaultAddress;\n        exitTime = _exitTime;\n    }\n\n    // It fakes generation of deposits and emits\n    function generateDeposits(\n        address[OUT_MAX_UTXOs] calldata tokens,\n        uint256[OUT_MAX_UTXOs] calldata tokenIds,\n        uint256[OUT_MAX_UTXOs] calldata extAmounts,\n        G1Point[OUT_MAX_UTXOs] calldata pubSpendingKeys,\n        uint256[CIPHERTEXT1_WORDS][OUT_MAX_UTXOs] calldata secrets,\n        uint32 createdAt\n    ) external override returns (uint256 leftLeafId) {\n        require(\n            createdAt <= block.timestamp,\n            \"FakePantherPoolV0:TOO_LARGE_createdAt\"\n        );\n        bytes32[OUT_MAX_UTXOs] memory commitments;\n        bytes memory utxoData = \"\";\n\n        for (uint256 utxoIndex = 0; utxoIndex < OUT_MAX_UTXOs; utxoIndex++) {\n            require(\n                pubSpendingKeys[utxoIndex].x < FIELD_SIZE,\n                \"FakePantherPoolV0:ERR_TOO_LARGE_PUBKEY.x\"\n            );\n            require(\n                pubSpendingKeys[utxoIndex].x < FIELD_SIZE,\n                \"FakePantherPoolV0:ERR_TOO_LARGE_PUBKEY.x\"\n            );\n            require(\n                tokenIds[utxoIndex] < FIELD_SIZE,\n                \"FakePantherPoolV0:TOO_LARGE_tokenId\"\n            );\n            require(\n                extAmounts[utxoIndex] < 2**96,\n                \"FakePantherPoolV0:ERR_TOO_LARGE_AMOUNT\"\n            );\n            require(\n                extAmounts[utxoIndex] != 0 ||\n                    (tokens[utxoIndex] == address(0) &&\n                        tokenIds[utxoIndex] == 0),\n                \"FakePantherPoolV0:ERR_WRONG_DEPOSIT\"\n            );\n\n            bytes memory thisUtxoData;\n            if (extAmounts[utxoIndex] == 0) {\n                // zero UTXO\n                commitments[utxoIndex] = ZERO_VALUE;\n                // UTXO_DATA_TYPE_ZERO\n                thisUtxoData = bytes.concat(abi.encodePacked(uint8(0xA0)));\n            } else {\n                // Fake (!!!) the commitment\n                commitments[utxoIndex] = bytes32(\n                    uint256(keccak256(abi.encode(block.timestamp, utxoIndex))) %\n                        FIELD_SIZE\n                );\n\n                // No scaling (!!!)\n                uint256 scaledAmount = extAmounts[utxoIndex];\n                uint256 tokenAndAmount = (uint256(uint160(tokens[utxoIndex])) <<\n                    96) | scaledAmount;\n\n                thisUtxoData = abi.encodePacked(\n                    uint8(0xAB), // UTXO_DATA_TYPE1\n                    secrets[utxoIndex],\n                    tokenAndAmount,\n                    tokenIds[utxoIndex]\n                );\n            }\n\n            utxoData = bytes.concat(utxoData, thisUtxoData);\n        }\n\n        uint256 n = fakeLeavesNum;\n        leftLeafId = ((n / 3) * 4) + (n % 3);\n        fakeLeavesNum = n + OUT_MAX_UTXOs;\n\n        emit NewCommitments(\n            leftLeafId,\n            block.timestamp, // creationTime,\n            commitments,\n            utxoData\n        );\n    }\n\n    function exit(\n        address, // token,\n        uint256, // tokenId,\n        uint256 amount,\n        uint32, // creationTime,\n        uint256 privSpendingKey,\n        uint256 leafId,\n        bytes32[PATH_ELEMENTS_NUM] calldata, // pathElements,\n        bytes32, // merkleRoot,\n        uint256 // cacheIndexHint\n    ) external override {\n        require(\n            block.timestamp >= exitTime,\n            \"FakePantherPoolV0:ERR_TOO_EARLY_EXIT\"\n        );\n        require(amount < 2**96, \"FakePantherPoolV0:ERR_TOO_LARGE_AMOUNT\");\n\n        // Fake (!!!) nullifier\n        bytes32 nullifier = bytes32(\n            uint256(keccak256(abi.encode(privSpendingKey, leafId))) % FIELD_SIZE\n        );\n\n        require(!isSpent[nullifier], \"FakePantherPoolV0:ERR_SPENT_NULLIFIER\");\n        isSpent[nullifier] = true;\n        emit Nullifier(nullifier);\n    }\n}\n"
    },
    "contracts/staking/mocks/MockAdvancedStakingDataDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.16;\n\nimport \"../actions/AdvancedStakingDataDecoder.sol\";\nimport \"../../common/Constants.sol\";\n\ncontract MockAdvancedStakingDataDecoder is AdvancedStakingDataDecoder {\n    function internalUnpackStakingData(bytes memory data)\n        external\n        pure\n        returns (\n            G1Point[OUT_RWRD_UTXOs] memory pubSpendingKeys,\n            uint256[CIPHERTEXT1_WORDS][OUT_RWRD_UTXOs] memory secrets\n        )\n    {\n        return unpackStakingData(data);\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockTriadIncrementalMerkleTrees.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../triadTree/TriadIncrementalMerkleTrees.sol\";\n\n// solhint-disable var-name-mixedcase\n// solhint-disable no-empty-blocks\n// solhint-disable func-name-mixedcase\ncontract MockTriadIncrementalMerkleTrees is TriadIncrementalMerkleTrees {\n    event InternalInsertBatch(uint256 leftLeafId);\n\n    function internal_TREE_DEPTH() external pure returns (uint256) {\n        return TREE_DEPTH;\n    }\n\n    function internal_ZERO_VALUE() external pure returns (bytes32) {\n        return ZERO_VALUE;\n    }\n\n    function internalInsertBatch(bytes32[TRIAD_SIZE] memory leaves) external {\n        uint256 leftLeafId = insertBatch(leaves);\n        emit InternalInsertBatch(leftLeafId);\n    }\n\n    function internalIsFullTree(uint256 nextLeafId)\n        external\n        pure\n        returns (bool)\n    {\n        return _isFullTree(nextLeafId);\n    }\n\n    function internalNextLeafId2LeavesNum(uint256 nextId)\n        external\n        pure\n        returns (uint256)\n    {\n        return _nextLeafId2LeavesNum(nextId);\n    }\n\n    // This function fakes just the '_nextLeafId', but it does not update the history of roots.\n    // If applied to the empty tree, equivalent to inserting ZERO leaves (but the history is empty).\n    // !!! If applied to a non-empty tree, or leaves \"really\" inserted after a \"fake\" insertion,\n    // the tree root will be incorrect.\n    function fakeNextLeafId(uint256 fakeId) external {\n        require((fakeId % 4) == 0, \"fakeId must be a multiple of 4\");\n        _nextLeafId = fakeId;\n    }\n}\n"
    },
    "contracts/protocol/mocks/MerkleProofVerifierTester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../triadTree/TriadIncrementalMerkleTrees.sol\";\nimport \"../pantherPool/MerkleProofVerifier.sol\";\nimport \"../pantherPool/PubKeyGenerator.sol\";\n\n// solhint-disable var-name-mixedcase\n// solhint-disable no-empty-blocks\n// solhint-disable func-name-mixedcase\n// solhint-disable state-visibility\ncontract MerkleProofVerifierTester is\n    MerkleProofVerifier,\n    TriadIncrementalMerkleTrees,\n    PubKeyGenerator\n{\n    bool _verifiedProof;\n\n    function testMerkleProof(\n        uint256 leafId,\n        bytes32 merkleRoot,\n        bytes32 commitment,\n        bytes32[TREE_DEPTH + 1] calldata pathElementss\n    ) external {\n        _verifiedProof = false;\n        verifyMerkleProof(\n            merkleRoot,\n            _getTriadIndex(leafId),\n            _getTriadNodeIndex(leafId),\n            commitment,\n            pathElementss\n        );\n        _verifiedProof = true;\n    }\n\n    function isProofVerified() external view returns (bool) {\n        return _verifiedProof;\n    }\n\n    function generatePublicSpendingKey(uint256 privKey)\n        external\n        view\n        returns (uint256[2] memory xy)\n    {\n        G1Point memory p;\n        p = generatePubSpendingKey(privKey);\n        xy[0] = p.x;\n        xy[1] = p.y;\n    }\n\n    uint256 leftLeafId;\n\n    function LeafId() external view returns (uint256) {\n        return leftLeafId;\n    }\n\n    function internalInsertBatch(bytes32[TRIAD_SIZE] memory leaves) external {\n        leftLeafId = insertBatch(leaves);\n    }\n\n    // DONT remove - it can be used to do internal testing of path-elements\n    /*\n    function internalInsertBatchZkp(bytes32[TRIAD_SIZE] memory leaves)\n        external\n    {\n        (leftLeafId, pathElements) = insertBatchZkp(leaves);\n    }\n\n     // DONT remove - can be used in tests - PUT IT INSIDE TriadIncrementalMerkleTree.sol to\n     // accept internal testing of path elements\n    function insertBatchZkp(bytes32[TRIAD_SIZE] memory leaves)\n        internal\n        returns (uint256 leftLeafId, bytes32[TREE_DEPTH] memory pathElements)\n    {\n        leftLeafId = _nextLeafId;\n\n        bytes32[TREE_DEPTH] memory zeros;\n        populateZeros(zeros);\n\n        // index of a \"current\" node (0 for the leftmost node/leaf of a level)\n        uint256 nodeIndex;\n        // hash (value) of a \"current\" node\n        bytes32 nodeHash;\n        // index of a \"current\" level (0 for leaves, increments toward root)\n        uint256 level;\n\n        // subtree from 3 leaves being inserted on `level = 0`\n        nodeHash = hash(leaves[0], leaves[1], leaves[2]);\n        // ... to be placed under this index on `level = 1`\n        // (equivalent to `(leftLeafId % iLEAVES_NUM) / iTRIAD_SIZE`)\n        nodeIndex = (leftLeafId & iLEAVES_NUM_MASK) >> iTRIAD_SIZE_BITS;\n\n        bytes32 left;\n        bytes32 right;\n        for (level = 1; level < TREE_DEPTH; level++) {\n            // if `nodeIndex` is, say, 25, over the iterations it will be:\n            // 25, 12, 6, 3, 1, 0, 0 ...\n\n            if (nodeIndex % 2 == 0) {\n                left = nodeHash;\n                right = zeros[level];\n                _filledSubtrees[level] = nodeHash;\n                pathElements[level - 1] = right;\n            } else {\n                // for a new tree, \"than\" block always run before \"else\" block\n                // so `_filledSubtrees[level]` gets updated before its use\n                left = _filledSubtrees[level];\n                right = nodeHash;\n                pathElements[level - 1] = left;\n            }\n\n            nodeHash = hash(left, right);\n\n            // equivalent to `nodeIndex /= 2`\n            nodeIndex >>= 1;\n        }\n\n        pathElements[TREE_DEPTH - 1] = nodeHash; // root\n\n        uint256 nextLeafId = leftLeafId + iTRIAD_SIZE;\n        _nextLeafId = nextLeafId;\n\n        uint256 treeId = getTreeId(leftLeafId);\n        if (_isFullTree(leftLeafId)) {\n            // Switch to a new tree\n            // Ignore `_filledSubtrees` old values as they are never re-used\n            finalRoots[treeId] = nodeHash;\n            emit AnchoredRoot(treeId, nodeHash);\n        } else {\n            uint256 cacheIndex = _nextLeafId2CacheIndex(nextLeafId);\n            _cachedRoots[cacheIndex] = uint256(nodeHash) ^ treeId;\n            emit CachedRoot(treeId, nodeHash);\n        }\n    }\n    // In use only when zkp part is activated\n    bytes32[TREE_DEPTH] pathElements;\n    function PathElements() external view returns (bytes32[TREE_DEPTH] memory) {\n        return pathElements;\n    }\n    */\n}\n"
    },
    "contracts/protocol/mocks/MockPubKeyGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { G1Point } from \"../../common/Types.sol\";\nimport \"../pantherPool/PubKeyGenerator.sol\";\n\ncontract MockPubKeyGenerator is PubKeyGenerator {\n    function internalGeneratePubSpendingKey(uint256 privKey)\n        external\n        view\n        returns (G1Point memory pubKey)\n    {\n        return generatePubSpendingKey(privKey);\n    }\n}\n"
    },
    "contracts/protocol/crypto/ElGamal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./BabyJubJub.sol\";\nimport \"../../common/Types.sol\";\n\ncontract ElGamalEncryption {\n    function add(ElGamalCiphertext memory ct1, ElGamalCiphertext memory ct2)\n        external\n        view\n        returns (ElGamalCiphertext memory ct3)\n    {\n        ct3.c1 = BabyJubJub.pointAdd(ct1.c1, ct2.c1);\n        ct3.c2 = BabyJubJub.pointAdd(ct1.c2, ct2.c2);\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockCommitmentGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../pantherPool/CommitmentGenerator.sol\";\n\ncontract MockCommitmentGenerator is CommitmentGenerator {\n    function internalGenerateCommitment(\n        uint256 pubSpendingKeyX,\n        uint256 pubSpendingKeyY,\n        uint64 scaledAmount,\n        uint160 zAssetId,\n        uint32 creationTime\n    ) external pure returns (bytes32 commitment) {\n        return\n            generateCommitment(\n                pubSpendingKeyX,\n                pubSpendingKeyY,\n                scaledAmount,\n                zAssetId,\n                creationTime\n            );\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockAmountConvertor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../pantherPool/AmountConvertor.sol\";\n\ncontract MockAmountConvertor is AmountConvertor {\n    function internalScaleAmount(uint256 amount, uint8 scale)\n        external\n        pure\n        returns (uint96 scaledAmount, uint256 change)\n    {\n        return _scaleAmount(amount, scale);\n    }\n\n    function internalUnscaleAmount(uint64 scaledAmount, uint8 scale)\n        external\n        pure\n        returns (uint96)\n    {\n        return _unscaleAmount(scaledAmount, scale);\n    }\n}\n"
    },
    "contracts/protocol/mocks/PantherPoolV0AndZAssetRegistryAndVaultTester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../PantherPoolV0.sol\";\nimport \"../Vault.sol\";\nimport \"../../common/Types.sol\";\nimport \"./MockPantherPoolV0.sol\";\nimport \"../ZAssetsRegistry.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract MyERC20 is ERC20 {\n    constructor(uint256 index, address owner)\n        ERC20(Strings.toString(index), Strings.toString(index))\n    {\n        uint256 totalSupply = 1024;\n        _mint(owner, totalSupply);\n    }\n    /*\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        console.logString(\" --- TOKEN --- \");\n        console.logString(\"msg.sender\");\n        console.log(msg.sender);\n        console.logString(\"Spender\");\n        console.log(spender);\n        console.logString(\"To\");\n        console.log(to);\n        console.logString(\"From\");\n        console.log(from);\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, scaledAmount);\n        return true;\n    }\n    */\n}\n\n// solhint-disable var-name-mixedcase\ncontract PantherPoolV0AndZAssetRegistryAndVaultTester is MockPantherPoolV0 {\n    address private registry;\n    MyERC20[OUT_UTXOs] private Tokens;\n\n    constructor()\n        MockPantherPoolV0(\n            address(this),\n            // This mock is the owner of ZAssetsRegistry and Vault\n            registry = address(new ZAssetsRegistry(address(this))),\n            address(new Vault(address(this)))\n        )\n    {\n        for (uint256 i = 0; i < OUT_UTXOs; ++i) {\n            Tokens[i] = new MyERC20(i, address(this)); // This mock is an owner of MyERC20\n            ZAsset memory z;\n            z.tokenType = ERC20_TOKEN_TYPE;\n            z.version = 0;\n            z.scale = 0;\n            z.token = address(Tokens[i]);\n            z.status = zASSET_ENABLED;\n            ZAssetsRegistry(registry).addZAsset(z);\n        }\n        exitTime = safe32TimeNow() + 1;\n    }\n\n    function testGetZAssetId(uint256 token, uint256 tokenId)\n        external\n        view\n        returns (uint160)\n    {\n        return\n            ZAssetsRegistry(registry).getZAssetId(\n                address(uint160(token)),\n                tokenId\n            );\n    }\n\n    function getTokenAddress(uint256 index) external view returns (address) {\n        return address(Tokens[index]);\n    }\n\n    function approveVault(uint256 amount, uint256 index) external {\n        Tokens[index].approve(VAULT, amount);\n    }\n\n    function generateDepositsExtended(\n        uint256[OUT_UTXOs] calldata extAmounts,\n        uint256[2] calldata pubKeys,\n        uint256[CIPHERTEXT1_WORDS] calldata secrets,\n        uint32 createdAt\n    ) external {\n        uint256[OUT_UTXOs] memory tokenIds;\n        tokenIds[0] = 0;\n        tokenIds[1] = 0;\n        tokenIds[2] = 0;\n\n        G1Point[OUT_UTXOs] memory pubKeyss;\n        pubKeyss[0] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[1] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[2] = G1Point(pubKeys[0], pubKeys[1]);\n\n        uint256[CIPHERTEXT1_WORDS][OUT_UTXOs] memory secretss;\n        secretss[0][0] = secrets[0];\n        secretss[0][1] = secrets[1];\n        secretss[1][0] = secrets[0];\n        secretss[1][1] = secrets[1];\n        secretss[2][0] = secrets[0];\n        secretss[2][1] = secrets[1];\n\n        for (uint256 i = 0; i < OUT_UTXOs; i++) {\n            this.approveVault(extAmounts[i], i);\n        }\n\n        this.generateDeposits(\n            [address(Tokens[0]), address(Tokens[1]), address(Tokens[2])],\n            tokenIds,\n            extAmounts,\n            pubKeyss,\n            secretss,\n            createdAt\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/staking/PNftToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./pNftToken/NativeMetaTransaction.sol\";\nimport \"./pNftToken/ContentMixin.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"./interfaces/INftGrantor.sol\";\n\n/**\n * @title PNftToken\n * @notice Panther NFT (PNFT) token on Polygon.\n * @dev If called by the \"minter\", it mints and grants one NFT to the address\n * given. The `AdvancedStakeRewardController` is supposed to be the minter and\n * call it to reward stakers with $PNFTs.\n * An immutable \"owner\" may update the minter and set the metadata (URIs) once.\n * Inspired and borrowed by/from the OpenSea's ERC721Tradable contract.\n * https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/ERC721Tradable.sol\n */\ncontract PNftToken is\n    ImmutableOwnable,\n    ERC721,\n    ContextMixin,\n    NativeMetaTransaction,\n    INftGrantor\n{\n    using Counters for Counters.Counter;\n\n    /**\n     * We rely on the OZ Counter util to keep track of the next available ID.\n     * We track the nextTokenId instead of the currentTokenId to save users on gas costs.\n     */\n    Counters.Counter private _nextTokenId;\n\n    /// @notice Operator (or user's Proxy Register) approved for all transactions\n    address public approvedForAll;\n    address public minter;\n\n    string public contractURI;\n    string public baseTokenURI;\n\n    event MinterUpdated(address _minter);\n    event TokenUriUpdated(string _tokenURI);\n    event ContractUriUpdated(string _contractURI);\n    event ApprovedForAllUpdated(address approvee);\n\n    constructor(\n        address _owner,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) ImmutableOwnable(_owner) {\n        // nextTokenId is initialized to 1, since starting at 0 leads to higher gas cost for the first minter\n        _nextTokenId.increment();\n        _initializeEIP712(_name);\n    }\n\n    /**\n     * @dev Returns the total tokens minted so far.\n     * 1 is always subtracted from the Counter since it tracks the next available tokenId.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _nextTokenId.current() - 1;\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        return\n            string(abi.encodePacked(baseTokenURI, Strings.toString(_tokenId)));\n    }\n\n    /**\n     * @dev Sets the minter address\n     * @param _minter The address that can mint token\n     */\n    function setMinter(address _minter) external onlyOwner {\n        require(_minter != address(0), \"Zero address\");\n        minter = _minter;\n\n        emit MinterUpdated(_minter);\n    }\n\n    /**\n     * @dev Sets the URI of the contract. it can be called\n     * only once by the owner\n     * @param _contractURI URI of the contract\n     */\n    function setContractURI(string calldata _contractURI) external onlyOwner {\n        require(!(bytes(contractURI).length > 0), \"Contract URI is defined\");\n\n        contractURI = _contractURI;\n\n        emit ContractUriUpdated(_contractURI);\n    }\n\n    /**\n     * @dev Sets the URI of the token. it can be called\n     * only once by the owner\n     * @param _baseTokenURI URI of the token\n     */\n    function setBaseTokenURI(string calldata _baseTokenURI) external onlyOwner {\n        require(!(bytes(baseTokenURI).length > 0), \"Base URI is defined\");\n\n        baseTokenURI = _baseTokenURI;\n\n        emit TokenUriUpdated(_baseTokenURI);\n    }\n\n    /**\n     * @dev Sets the address of the \"operator\" approved for all transactions.\n     * May be set by the owner only.\n     * @param approvee Approved address. It may be a Panther's contract or\n     * OpenSea's ERC721 Proxy Registry, which is at\n     * matic:0x58807baD0B376efc12F5AD86aAc70E78ed67deaE\n     * (mumbai:0xff7Ca10aF37178BdD056628eF42fD7F799fAc77c)\n     */\n    function setApprovedForAllOperator(address approvee) external onlyOwner {\n        // Zero address allowed (meaning \"no account is set\")\n        // slither-disable-next-line missing-zero-check\n        approvedForAll = approvee;\n        emit ApprovedForAllUpdated(approvee);\n    }\n\n    /**\n     * @dev Mints a token to an address with a tokenURI.\n     * @param _to address of the future owner of the token\n     */\n    function grantOneToken(address _to)\n        external\n        virtual\n        returns (uint256 currentTokenId)\n    {\n        require(_msgSender() == minter, \"Only minter\");\n\n        currentTokenId = _nextTokenId.current();\n        _nextTokenId.increment();\n        _safeMint(_to, currentTokenId);\n    }\n\n    /**\n     * Override isApprovedForAll to whitelist a Panther authorized account or\n     * user's OpenSea proxy accounts to enable gas-less transactions/listings.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        if (super.isApprovedForAll(owner, operator)) return true;\n\n        // if \"approved for all\" operator (proxy registry) is detected, return true\n        address approvee = approvedForAll;\n        return (approvee != address(0)) && (approvee == operator);\n    }\n\n    /**\n     * This is used instead of msg.sender as transactions might be sent by a relayer rather than by a user directly.\n     */\n    function _msgSender() internal view override returns (address sender) {\n        return ContextMixin.msgSender();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/staking/pNftToken/NativeMetaTransaction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line max-line-length\n// Source: https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/common/meta-transactions/NativeMetaTransaction.sol\n\npragma solidity ^0.8.16;\n\nimport { EIP712Base } from \"./EIP712Base.sol\";\n\n/**\n * @title NativeMetaTransaction contract\n * @dev It enables gasless user transactions\n */\ncontract NativeMetaTransaction is EIP712Base {\n    bytes32 private constant META_TRANSACTION_TYPEHASH =\n        keccak256(\n            bytes(\n                \"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\"\n            )\n        );\n    event MetaTransactionExecuted(\n        address userAddress,\n        address payable relayerAddress,\n        bytes functionSignature\n    );\n    mapping(address => uint256) private nonces;\n\n    /*\n     * Meta transaction structure.\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\n     * He should call the desired function directly in that case.\n     */\n    struct MetaTransaction {\n        uint256 nonce;\n        address from;\n        bytes functionSignature;\n    }\n\n    // slither-disable-next-line locked-ether\n    function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress] + 1;\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        // solhint-disable avoid-low-level-calls\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        // solhint-enable avoid-low-level-calls\n\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }\n\n    function hashMetaTransaction(MetaTransaction memory metaTx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    META_TRANSACTION_TYPEHASH,\n                    metaTx.nonce,\n                    metaTx.from,\n                    keccak256(metaTx.functionSignature)\n                )\n            );\n    }\n\n    function getNonce(address user) public view returns (uint256 nonce) {\n        nonce = nonces[user];\n    }\n\n    function verify(\n        address signer,\n        MetaTransaction memory metaTx,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) internal view returns (bool) {\n        require(signer != address(0), \"NativeMetaTransaction: INVALID_SIGNER\");\n        return\n            signer ==\n            ecrecover(\n                toTypedMessageHash(hashMetaTransaction(metaTx)),\n                sigV,\n                sigR,\n                sigS\n            );\n    }\n}\n"
    },
    "contracts/staking/pNftToken/ContentMixin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line max-line-length\n// Source: https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/common/meta-transactions/ContentMixin.sol\n\npragma solidity ^0.8.16;\n\n/**\n * @title ContextMixin contract\n * @dev It supports gasless user transactions\n */\nabstract contract ContextMixin {\n    function msgSender() internal view returns (address payable sender) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            // solhint-disable no-inline-assembly\n            // slither-disable-next-line assembly\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n            // solhint-enable no-inline-assembly\n        } else {\n            sender = payable(msg.sender);\n        }\n        return sender;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/staking/pNftToken/EIP712Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line max-line-length\n// Source: https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/common/meta-transactions/EIP712Base.sol\n\npragma solidity ^0.8.16;\n\nimport { Initializable } from \"./Initializable.sol\";\n\n/**\n * @title EIP712Base contract\n */\ncontract EIP712Base is Initializable {\n    struct EIP712Domain {\n        string name;\n        string version;\n        address verifyingContract;\n        bytes32 salt;\n    }\n\n    string public constant ERC712_VERSION = \"1\";\n\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\"\n            )\n        );\n    bytes32 internal domainSeperator;\n\n    // supposed to be called once while initializing.\n    // one of the contracts that inherits this contract follows proxy pattern\n    // so it is not possible to do this in a constructor\n    function _initializeEIP712(string memory name) internal initializer {\n        _setDomainSeperator(name);\n    }\n\n    function _setDomainSeperator(string memory name) internal {\n        domainSeperator = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(ERC712_VERSION)),\n                address(this),\n                bytes32(getChainId())\n            )\n        );\n    }\n\n    function getDomainSeperator() public view returns (bytes32) {\n        return domainSeperator;\n    }\n\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n\n        // solhint-disable no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            id := chainid()\n        }\n        // solhint-enable no-inline-assembly\n\n        return id;\n    }\n\n    /**\n     * Accept message hash and returns hash message in EIP712 compatible form\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\n     * https://eips.ethereum.org/EIPS/eip-712\n     * \"\\\\x19\" makes the encoding deterministic\n     * \"\\\\x01\" is the version byte to make it compatible to EIP-191\n     */\n    function toTypedMessageHash(bytes32 messageHash)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(), messageHash)\n            );\n    }\n}\n"
    },
    "contracts/staking/pNftToken/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line max-line-length\n// Source: https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/common/meta-transactions/Initializable.sol\n\npragma solidity ^0.8.16;\n\n/**\n * @title Initializable contract\n */\ncontract Initializable {\n    bool private inited = false;\n\n    modifier initializer() {\n        require(!inited, \"already inited\");\n        _;\n        inited = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/protocol/mocks/IMockTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable no-empty-blocks\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n// Used with `@defi-wonderland/smock` package to mock token contracts\n\ninterface IMockErc20 is IERC20 {\n\n}\n\ninterface IMockErc721 is IERC721 {}\n\ninterface IMockErc1155 is IERC1155 {}\n"
    },
    "contracts/staking/mocks/TokenMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n// mocked methods of ZKPToken\ncontract TokenMock is ERC20Permit {\n    constructor() ERC20Permit(\"TEST\") ERC20(\"TEST\", \"TT\") {\n        _mint(msg.sender, 1e27);\n    }\n}\n\ncontract ERC721Mock is ERC721 {\n    uint256 private _tokenId;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() ERC721(\"TEST\", \"TT\") {}\n\n    function mintBatch(address _to, uint256 _amount) external {\n        for (uint256 i = 0; i < _amount; i++) {\n            _mint(_to, _tokenId);\n            _tokenId++;\n        }\n    }\n\n    function grantOneToken(address _to) external returns (uint256 id) {\n        id = _tokenId;\n        _mint(_to, id);\n\n        _tokenId++;\n    }\n}\n"
    },
    "contracts/protocol/PrpGrantor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./errMsgs/PrpGrantorErrMsgs.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"./interfaces/IPrpGrantor.sol\";\n\n/**\n * @title PrpGrantor\n * @notice It registers issuing and redemption of PRP-nominated \"grants\"\n * @dev The owner may add (enable) new \"grant types\" or remove (disable) existing types. For every\n * type, the owner specifies (authorizes) the account of the \"curator\" and the amount of the grant\n * (in Panther Reward Points, aka \"PRPs\").\n * A curator calls `issueGrant` on this contract to issue a \"grant\" of a certain type to a grantee.\n * The curator must be authorized by the owner for this grant type.\n * Independently from curators, the owner may call `issueOwnerGrant` to issue a grant to a grantee.\n * In this case the amount is specified as the call param, rather than via the grant type.\n * Every `issueGrant` or `issueOwnerGrant` call increases the amount (in PRPs) of \"unused grants\"\n * for the grantee.\n * The authorized \"processor\" (one for all grant types) may call `redeemGrant` to account for usage\n * (i.e.  redemption) of grants. Every `redeemGrant` call decreases the amount of unused grants for\n * the grantee.\n * Assumed:\n * - the \"processor\" is the `PantherPool` contract\n * - a grant is redeemed when the PantherPool creates a PRP-nominated UTXO for a grantee.\n */\ncontract PrpGrantor is ImmutableOwnable, IPrpGrantor {\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    // Max amount in PRPs\n    uint256 private constant MAX_PRP_GRANT = 2**32;\n\n    // To distinguish \"undefined\" from \"zero\"\n    uint256 private constant ZERO_AMOUNT = 1;\n    uint256 private constant UNDEF_AMOUNT = 0;\n\n    // bytes4(keccak('issueOwnerGrant(address,uint256)'))\n    bytes4 private constant OWNER_GRANT_TYPE = 0x479ed83f;\n\n    // Account authorized to call `redeemGrant`\n    address private immutable GRANT_PROCESSOR;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @dev Mapping from \"curator\" to \"grant type\" to \"grant amount in PRPs\"\n    /// To distinguish \"zero\" from \"undefined\", values are biased by `ZERO_AMOUNT`\n    mapping(address => mapping(bytes4 => uint256)) private _prpGrantsAmounts;\n\n    /// @dev mapping from \"grantee\" to the PRP amount that may be \"used\"\n    mapping(address => uint256) private _unusedPrpGrants;\n\n    // Total amount (in PRPs) of grants issued so far\n    uint256 public override totalGrantsIssued;\n\n    // Total amount (in PRPs) of grants redeemed so far\n    // (excluding burnt grants amounts)\n    uint256 public override totalGrantsRedeemed;\n\n    // slither-disable-next-line similar-names\n    constructor(address _owner, address _grantProcessor)\n        ImmutableOwnable(_owner)\n    {\n        // As it runs behind the DELEGATECALL'ing proxy, initialization of\n        // immutable \"vars\" only is allowed in the constructor\n        require(_grantProcessor != address(0), ERR_ZERO_PROCESSOR_ADDR);\n        GRANT_PROCESSOR = _grantProcessor;\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function grantProcessor() external view override returns (address) {\n        return GRANT_PROCESSOR;\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function getUnusedGrantAmount(address grantee)\n        external\n        view\n        override\n        returns (uint256 prpAmount)\n    {\n        return _unusedPrpGrants[grantee];\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function getGrantAmount(address curator, bytes4 grantType)\n        external\n        view\n        override\n        returns (uint256 prpAmount)\n    {\n        prpAmount = _prpGrantsAmounts[curator][grantType];\n        _revertOnUndefPrpAmount(prpAmount);\n        // In this and other `unchecked` blocks, over/underflow impossible since:\n        // - prpAmount is limited when granted and can never exceed MAX_PRP_GRANT\n        // - prpAmount's summation (accumulation) can't practically exceed 2**256\n        // - prpAmount is checked to be equal or more than the value subtracted\n        // - prpAmount checked to be less or equal the value it's subtracted from\n        unchecked {\n            prpAmount -= ZERO_AMOUNT;\n        }\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function issueGrant(address grantee, bytes4 grantType)\n        external\n        override\n        nonZeroGrantType(grantType)\n        returns (uint256 prpAmount)\n    {\n        require(grantee != address(0), ERR_ZERO_GRANTEE_ADDR);\n        prpAmount = _prpGrantsAmounts[msg.sender][grantType];\n        _revertOnUndefPrpAmount(prpAmount);\n        unchecked {\n            prpAmount -= ZERO_AMOUNT;\n        }\n        _issueGrant(grantee, prpAmount, grantType);\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function issueOwnerGrant(address grantee, uint256 prpAmount)\n        external\n        override\n        onlyOwner\n    {\n        require(grantee != address(0), ERR_ZERO_GRANTEE_ADDR);\n        _revertOnTooBigPrpAmount(prpAmount);\n        _issueGrant(grantee, prpAmount, OWNER_GRANT_TYPE);\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function burnGrant(uint256 prpAmount) external override {\n        uint256 oldBalance = _unusedPrpGrants[msg.sender];\n        require(oldBalance >= prpAmount, ERR_LOW_GRANT_BALANCE);\n        unchecked {\n            _unusedPrpGrants[msg.sender] = oldBalance - prpAmount;\n            totalGrantsIssued -= prpAmount;\n        }\n        emit PrpGrantBurnt(msg.sender, prpAmount);\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function redeemGrant(address grantee, uint256 prpAmount) external override {\n        require(msg.sender == GRANT_PROCESSOR, ERR_UNAUTHORIZED_CALL);\n        uint256 oldBalance = _unusedPrpGrants[grantee];\n        require(oldBalance >= prpAmount, ERR_LOW_GRANT_BALANCE);\n        unchecked {\n            _unusedPrpGrants[grantee] = oldBalance - prpAmount;\n            totalGrantsRedeemed += prpAmount;\n        }\n        emit PrpGrantRedeemed(grantee, prpAmount);\n    }\n\n    /// @dev Add a new \"grant type\", with the specified amount (in PRPs) of the grant, and\n    /// allow the specified \"curator\" to issue grants of this type (by calling `issueGrant`).\n    /// Only the owner may call.\n    function enableGrantType(\n        address curator,\n        bytes4 grantType,\n        uint256 prpAmount\n    ) external onlyOwner nonZeroGrantType(grantType) {\n        require(curator != address(0), ERR_ZERO_CURATOR_ADDR);\n        _revertOnTooBigPrpAmount(prpAmount);\n        require(\n            _prpGrantsAmounts[curator][grantType] == UNDEF_AMOUNT,\n            ERR_GRANT_TYPE_EXISTS\n        );\n        _prpGrantsAmounts[curator][grantType] = ZERO_AMOUNT + prpAmount;\n        emit PrpGrantEnabled(curator, grantType, prpAmount);\n    }\n\n    /// @dev Disable previously enabled \"grant type\".\n    /// Only the owner may call.\n    function disableGrantType(address curator, bytes4 grantType)\n        external\n        onlyOwner\n        nonZeroGrantType(grantType)\n    {\n        _revertOnUndefPrpAmount(_prpGrantsAmounts[curator][grantType]);\n        _prpGrantsAmounts[curator][grantType] = UNDEF_AMOUNT;\n        emit PrpGrantDisabled(curator, grantType);\n    }\n\n    /// Modifiers and private functions follow\n\n    modifier nonZeroGrantType(bytes4 grantType) {\n        require(grantType != bytes4(0), ERR_UKNOWN_GRANT_TYPE);\n        _;\n    }\n\n    function _revertOnTooBigPrpAmount(uint256 prpAmount) private pure {\n        require(prpAmount <= MAX_PRP_GRANT, ERR_TOO_LARGE_GRANT_AMOUNT);\n    }\n\n    function _revertOnUndefPrpAmount(uint256 prpAmount) private pure {\n        require(prpAmount != UNDEF_AMOUNT, ERR_UNDEF_GRANT);\n    }\n\n    function _issueGrant(\n        address grantee,\n        uint256 prpAmount,\n        bytes4 grantType\n    ) private {\n        unchecked {\n            if (prpAmount != 0) {\n                uint256 newBalance = _unusedPrpGrants[grantee] + prpAmount;\n                _revertOnTooBigPrpAmount(newBalance);\n                _unusedPrpGrants[grantee] = newBalance;\n                totalGrantsIssued += prpAmount;\n            }\n        }\n        emit PrpGrantIssued(grantType, grantee, prpAmount);\n    }\n}\n"
    },
    "contracts/protocol/errMsgs/PrpGrantorErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_ZERO_PROCESSOR_ADDR = \"GR:E0\";\nstring constant ERR_ZERO_CURATOR_ADDR = \"GR:E1\";\nstring constant ERR_ZERO_GRANTEE_ADDR = \"GR:E2\";\nstring constant ERR_GRANT_TYPE_EXISTS = \"GR:E3\";\nstring constant ERR_UNEXPECTED_GRANT_RECEIPIENT = \"GR:E4\";\nstring constant ERR_LOW_GRANT_BALANCE = \"GR:E5\";\nstring constant ERR_UKNOWN_GRANT_TYPE = \"GR:E6\";\nstring constant ERR_TOO_LARGE_GRANT_AMOUNT = \"GR:E7\";\nstring constant ERR_UNDEF_GRANT = \"GR:E8\";\nstring constant ERR_UNAUTHORIZED_CALL = \"GR:Unauthorized\";\n"
    },
    "contracts/staking/AdvancedStakeRewardAdviserAndMsgSender.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./actions/AdvancedStakingBridgedDataCoder.sol\";\nimport \"./actions/Constants.sol\";\nimport \"./interfaces/IActionMsgReceiver.sol\";\nimport \"./interfaces/IFxStateSender.sol\";\nimport \"./StakeZeroRewardAdviser.sol\";\n\n/***\n * @title AdvancedStakeRewardAdviserAndMsgSender\n * @notice The \"zero reward adviser\" for the `RewardMaster` that sends `STAKE` action messages over\n * the PoS bridge to the STAKE_MSG_RECEIVER.\n * @dev It is assumed to run on the mainnet/Goerli and be authorized with the `RewardMaster` on the\n * same network as the \"Reward Adviser\" for \"advanced\" stakes.\n * As the \"Reward Adviser\" it gets called `getRewardAdvice` by the `RewardMaster` every time a user\n * creates or withdraws an \"advanced\" stake. It returns the \"zero\" advices, i.e. the `Advice` data\n * structure with zero `sharesToCreate` and `sharesToRedeem`.\n * On \"zero\" advices, the RewardMaster skips creating/redeeming \"treasure shares\" for/to stakers.\n * If the `getRewardAdvice` is called w/ the action STAKE (i.e. a new stake is being created), this\n * contract sends the STAKE message over the \"Fx-Portal\" (the PoS bridge run by the Polygon team)\n * to the STAKE_MSG_RECEIVER on the Polygon/Mumbai. The STAKE_MSG_RECEIVER is supposed to be the\n * `AdvancedStakeActionMsgRelayer` contract that processes the bridged messages, rewarding stakers\n * on the Polygon/Mumbai.\n */\ncontract AdvancedStakeRewardAdviserAndMsgSender is\n    StakeZeroRewardAdviser,\n    AdvancedStakingBridgedDataCoder\n{\n    event StakeMsgBridged(uint256 _nonce, bytes data);\n\n    // solhint-disable var-name-mixedcase\n\n    /// @notice Address of the `FxRoot` contract on the mainnet/Goerli network\n    /// @dev `FxRoot` is the contract of the \"Fx-Portal\" on the mainnet/Goerli.\n    address public immutable FX_ROOT;\n\n    /// @notice Address of the RewardMaster contract on the mainnet/Goerli\n    address public immutable REWARD_MASTER;\n\n    /// @notice Address on the AdvancedStakeActionMsgRelayer on the Polygon/Mumbai\n    address public immutable ACTION_MSG_RECEIVER;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice Message nonce (i.e. sequential number of the latest message)\n    uint256 public nonce;\n\n    /// @param _rewardMaster Address of the RewardMaster contract on the mainnet/Goerli\n    /// @param _actionMsgReceiver Address of the AdvancedStakeActionMsgRelayer on Polygon/Mumbai\n    /// @param _fxRoot Address of the `FxRoot` (PoS Bridge) contract on mainnet/Goerli\n    constructor(\n        // slither-disable-next-line similar-names\n        address _rewardMaster,\n        address _actionMsgReceiver,\n        address _fxRoot\n    ) StakeZeroRewardAdviser(ADVANCED_STAKE, ADVANCED_UNSTAKE) {\n        require(\n            _fxRoot != address(0) &&\n                _actionMsgReceiver != address(0) &&\n                _rewardMaster != address(0),\n            \"AMS:E01\"\n        );\n\n        FX_ROOT = _fxRoot;\n        REWARD_MASTER = _rewardMaster;\n        ACTION_MSG_RECEIVER = _actionMsgReceiver;\n    }\n\n    // It is called withing the `function getRewardAdvice`\n    function _onRequest(bytes4 action, bytes memory message) internal override {\n        // Ignore other messages except the STAKE\n        if (action != STAKE) return;\n\n        // Overflow ignored as the nonce is unexpected ever be that big\n        uint24 _nonce = uint24(nonce + 1);\n        nonce = uint256(_nonce);\n\n        bytes memory content = _encodeBridgedData(_nonce, action, message);\n        // known contract call - no need in reentrancy guard\n        // slither-disable-next-line reentrancy-benign,reentrancy-events\n        IFxStateSender(FX_ROOT).sendMessageToChild(\n            ACTION_MSG_RECEIVER,\n            content\n        );\n\n        emit StakeMsgBridged(_nonce, content);\n    }\n}\n"
    },
    "contracts/staking/actions/AdvancedStakingBridgedDataCoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/***\n * @title AdvancedStakingBridgedDataDecoder\n * @dev It encode (pack) and decodes (unpack) messages for bridging them between networks\n */\nabstract contract AdvancedStakingBridgedDataCoder {\n    function _encodeBridgedData(\n        uint24 _nonce,\n        bytes4 action,\n        bytes memory message\n    ) internal pure returns (bytes memory content) {\n        content = abi.encodePacked(_nonce, action, message);\n    }\n\n    // For efficiency we use \"packed\" (rather than \"ABI\") encoding.\n    // It results in shorter data, but requires custom unpack function.\n    function _decodeBridgedData(bytes memory content)\n        internal\n        pure\n        returns (\n            uint256 _nonce,\n            bytes4 action,\n            bytes memory message\n        )\n    {\n        require(content.length >= 7, \"ABD:WRONG_LENGTH\");\n\n        _nonce =\n            (uint256(uint8(content[0])) << 16) |\n            (uint256(uint8(content[1])) << 8) |\n            uint256(uint8(content[2]));\n\n        action = bytes4(\n            uint32(\n                (uint256(uint8(content[3])) << 24) |\n                    (uint256(uint8(content[4])) << 16) |\n                    (uint256(uint8(content[5])) << 8) |\n                    uint256(uint8(content[6]))\n            )\n        );\n\n        uint256 curPos = 7;\n        uint256 msgLength = content.length - curPos;\n        message = new bytes(msgLength);\n        if (msgLength > 0) {\n            uint256 i = 0;\n            while (i < msgLength) {\n                message[i++] = content[curPos++];\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/interfaces/IActionMsgReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IActionMsgReceiver {\n    function onAction(bytes4 action, bytes memory message) external;\n}\n"
    },
    "contracts/staking/interfaces/IFxStateSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/***\n * @dev An interface of the `FxRoot` contract\n * `FxRoot` is the contract of the \"Fx-Portal\" (a PoS bridge run by the Polygon team) on the\n * mainnet/Goerli network. It passes data to s user-defined contract on the Polygon/Mumbai.\n * See https://docs.polygon.technology/docs/develop/l1-l2-communication/fx-portal\n */\ninterface IFxStateSender {\n    function sendMessageToChild(address _receiver, bytes calldata _data)\n        external;\n}\n"
    },
    "contracts/staking/StakeZeroRewardAdviser.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./actions/StakingMsgProcessor.sol\";\nimport \"./interfaces/IRewardAdviser.sol\";\n\n/**\n * @title StakeZeroRewardAdviser\n * @notice The \"reward adviser\" for the `RewardMaster` that returns the \"zero reward advice\" only.\n * @dev The \"zero\" reward advice is the `Advice` with zero `sharesToCreate` and `sharesToRedeem`.\n * On \"zero\" advices, the RewardMaster skips creating/redeeming \"treasure shares\" for/to stakers.\n */\nabstract contract StakeZeroRewardAdviser is\n    StakingMsgProcessor,\n    IRewardAdviser\n{\n    // solhint-disable var-name-mixedcase\n\n    // `stakeAction` for the STAKE\n    bytes4 internal immutable STAKE;\n\n    // `stakeAction` for the UNSTAKE\n    bytes4 internal immutable UNSTAKE;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @param stakeAction The STAKE action type (see StakingMsgProcessor::_encodeStakeActionType)\n    /// @param unstakeAction The UNSTAKE action type (see StakingMsgProcessor::_encodeUNstakeActionType)\n    constructor(bytes4 stakeAction, bytes4 unstakeAction) {\n        require(\n            stakeAction != bytes4(0) && unstakeAction != bytes4(0),\n            \"ZRA:E1\"\n        );\n        STAKE = stakeAction;\n        UNSTAKE = unstakeAction;\n    }\n\n    /// @dev It is assumed to be called by the RewardMaster contract.\n    /// It returns the \"zero\" reward advises, no matter who calls it.\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        override\n        returns (Advice memory)\n    {\n        require(\n            action == STAKE || action == UNSTAKE,\n            \"ZRA: unsupported action\"\n        );\n\n        _onRequest(action, message);\n\n        // Return the \"zero\" advice\n        return\n            Advice(\n                address(0), // createSharesFor\n                0, // sharesToCreate\n                address(0), // redeemSharesFrom\n                0, // sharesToRedeem\n                address(0) // sendRewardTo\n            );\n    }\n\n    // solhint-disable no-empty-blocks\n    // slither-disable-next-line dead-code\n    function _onRequest(bytes4 action, bytes memory message) internal virtual {\n        // Child contracts may re-define it\n    }\n    // solhint-enable no-empty-blocks\n}\n"
    },
    "contracts/staking/AdvancedStakeActionMsgRelayer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./actions/AdvancedStakingBridgedDataCoder.sol\";\nimport \"./interfaces/IActionMsgReceiver.sol\";\nimport \"./interfaces/IFxMessageProcessor.sol\";\n\n/***\n * @title AdvancedStakeActionMsgRelayer\n * @notice It re-translates messages on new \"advanced\" stakes created on the mainnet (or Goerli)\n * network to the `RewardMaster` contract running on the Polygon (or Mumbai) network.\n * @dev It is assumed to run on the Polygon (or Mumbai) network.\n * Like the `Staking` contract, this contract acts as the \"Action Oracle\" for the RewardMaster, and\n * this contract must be registered as the oracle with the latest.\n * It receives STAKE action messages (on new \"advanced\" stakes created) from the `FxChild` contract\n * (a contract of the \"Fx-Portal\" PoS bridge), sanitizes and relays messages to the RewardMaster on\n * the Polygon (or Mumbai).\n * The `AdvancedStakeRewardAdviserAndMsgSender` contract, a counterpart to this contract that runs\n * on the mainnet (or Goerli) network, sends these messages to this contract over the bridge.\n */\ncontract AdvancedStakeActionMsgRelayer is\n    AdvancedStakingBridgedDataCoder,\n    IFxMessageProcessor\n{\n    event StakeMsgRelayed(uint256 _nonce, bytes data);\n\n    // solhint-disable var-name-mixedcase\n\n    /// @notice Address of the `FxChild` contract on the Polygon/Mumbai network\n    /// @dev `FxChild` is the contract of the \"Fx-Portal\" on the Polygon/Mumbai\n    address public immutable FX_CHILD;\n\n    /// @notice Address of the RewardMaster contract on the Polygon/Mumbai\n    address public immutable REWARD_MASTER;\n\n    /// @notice Address of the AdvancedStakeRewardAdviserAndMsgSender on the mainnet/Goerli\n    /// @dev It sends messages over the PoS bridge to this contract\n    address public immutable STAKE_MSG_SENDER;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice Message nonce (i.e. sequential number of the latest message)\n    uint256 public nonce;\n\n    /// @param _rewardMaster Address of the RewardMaster contract on the Polygon/Mumbai\n    /// @param _stakeMsgSender Address of the AdvancedStakeRewardAdviserAndMsgSender on the mainnet/Goerli\n    /// @param _fxChild Address of the `FxChild` (Bridge) contract on Polygon/Mumbai\n    constructor(\n        // slither-disable-next-line similar-names\n        address _rewardMaster,\n        address _stakeMsgSender,\n        address _fxChild\n    ) {\n        require(\n            _fxChild != address(0) &&\n                _stakeMsgSender != address(0) &&\n                _rewardMaster != address(0),\n            \"AMR:E01\"\n        );\n\n        FX_CHILD = _fxChild;\n        REWARD_MASTER = _rewardMaster;\n        STAKE_MSG_SENDER = _stakeMsgSender;\n    }\n\n    /// @dev Sanitizes, decodes and relay to the RewardMaster the STAKE action message.\n    /// PoS bridge validators call this method via the `FxChild` contract each time\n    /// a new message is posted to the bridge on the mainnet/Goerli\n    /// @param rootMessageSender Address on the mainnet/Goerli that sent the message\n    /// @param content Message data\n    function processMessageFromRoot(\n        uint256, // stateId (Polygon PoS Bridge state sync ID, unused)\n        address rootMessageSender,\n        bytes calldata content\n    ) external override {\n        require(msg.sender == FX_CHILD, \"AMR:INVALID_CALLER\");\n        require(rootMessageSender == STAKE_MSG_SENDER, \"AMR:INVALID_SENDER\");\n\n        (\n            uint256 _nonce,\n            bytes4 action,\n            bytes memory message\n        ) = _decodeBridgedData(content);\n\n        // Protection against replay attacks/errors. It's supposed that:\n        // - failed `.onAction` shall not stop further messages bridging\n        // - nonce is expected never be large enough to overflow.\n        require(_nonce > nonce, \"AMR:INVALID_NONCE\");\n        nonce = _nonce;\n\n        // trusted contract call - no reentrancy guard needed\n        // slither-disable-next-line reentrancy-benign,reentrancy-events\n        IActionMsgReceiver(REWARD_MASTER).onAction(action, message);\n\n        emit StakeMsgRelayed(_nonce, content);\n    }\n}\n"
    },
    "contracts/staking/interfaces/IFxMessageProcessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/***\n * @dev A receiver on the Polygon (or Mumbai) network of a message sent over the\n * \"Fx-Portal\" must implement this interface.\n * The \"Fx-Portal\" is the PoS bridge run by the Polygon team.\n * See https://docs.polygon.technology/docs/develop/l1-l2-communication/fx-portal\n */\ninterface IFxMessageProcessor {\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/staking/mocks/MockAdvancedStakingBridgedDataCoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.16;\n\nimport \"../actions/AdvancedStakingBridgedDataCoder.sol\";\n\ncontract MockAdvancedStakingBridgedDataCoder is\n    AdvancedStakingBridgedDataCoder\n{\n    function internalEncodeBridgedData(\n        uint24 _nonce,\n        bytes4 action,\n        bytes memory message\n    ) external pure returns (bytes memory content) {\n        return _encodeBridgedData(_nonce, action, message);\n    }\n\n    function internalDecodeBridgedData(bytes memory content)\n        external\n        pure\n        returns (\n            uint256 _nonce,\n            bytes4 action,\n            bytes memory message\n        )\n    {\n        return _decodeBridgedData(content);\n    }\n}\n"
    },
    "contracts/staking/interfaces/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IRewardPool {\n    /// @notice Returns token amount that may be released (vested) now\n    function releasableAmount() external view returns (uint256);\n\n    /// @notice Vests releasable token amount to the {recipient}\n    /// @dev {recipient} only may call\n    function vestRewards() external returns (uint256 amount);\n\n    /// @notice Emitted on vesting to the {recipient}\n    event Vested(uint256 amount);\n\n    /// @notice Emitted on parameters initialized.\n    event Initialized(uint256 _poolId, address _recipient, uint256 _endTime);\n}\n"
    },
    "contracts/staking/interfaces/IVestingPools.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IVestingPools {\n    /**\n     * @notice Returns Token address.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Returns the wallet address of the specified pool.\n     */\n    function getWallet(uint256 poolId) external view returns (address);\n\n    /**\n     * @notice Returns the amount that may be vested now from the given pool.\n     */\n    function releasableAmount(uint256 poolId) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount that has been vested from the given pool\n     */\n    function vestedAmount(uint256 poolId) external view returns (uint256);\n\n    /**\n     * @notice Vests the specified amount from the given pool to the pool wallet.\n     * If the amount is zero, it vests the entire \"releasable\" amount.\n     * @dev Pool wallet may call only.\n     * @return released - Amount released.\n     */\n    function release(uint256 poolId, uint256 amount)\n        external\n        returns (uint256 released);\n\n    /**\n     * @notice Vests the specified amount from the given pool to the given address.\n     * If the amount is zero, it vests the entire \"releasable\" amount.\n     * @dev Pool wallet may call only.\n     * @return released - Amount released.\n     */\n    function releaseTo(\n        uint256 poolId,\n        address account,\n        uint256 amount\n    ) external returns (uint256 released);\n\n    /**\n     * @notice Updates the wallet for the given pool.\n     * @dev Only address with the 'wallet' role may call.\n     */\n    function updatePoolWallet(uint256 poolId, address newWallet) external;\n\n    /// @notice Emitted on an amount vesting.\n    event Released(uint256 indexed poolId, address to, uint256 amount);\n}\n"
    },
    "contracts/staking/actions/RewardAdvisersList.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IRewardAdviser.sol\";\n\n/**\n * @title ActionControllers\n * @notice It maintains a list of \"ActionOracle\" and \"RewardAdviser\" instances.\n * For a tuple of ActionOracle address and action type, an RewardAdviser\n * instance of  may be mapped.\n */\nabstract contract RewardAdvisersList {\n    /// @dev Emitted when RewardAdviser added, updated, or removed\n    event AdviserUpdated(\n        address indexed oracle,\n        bytes4 indexed action,\n        address adviser\n    );\n\n    /// @dev mapping from ActionOracle and (type of) action to ActionController\n    mapping(address => mapping(bytes4 => address)) public rewardAdvisers;\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function _addRewardAdviser(\n        address oracle,\n        bytes4 action,\n        address adviser\n    ) internal {\n        require(\n            oracle != address(0) &&\n                adviser != address(0) &&\n                action != bytes4(0),\n            \"ACM:E1\"\n        );\n        require(rewardAdvisers[oracle][action] == address(0), \"ACM:E2\");\n        rewardAdvisers[oracle][action] = adviser;\n        emit AdviserUpdated(oracle, action, adviser);\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function _removeRewardAdviser(address oracle, bytes4 action) internal {\n        require(rewardAdvisers[oracle][action] != address(0), \"ACM:E3\");\n        rewardAdvisers[oracle][action] = address(0);\n        emit AdviserUpdated(oracle, action, address(0));\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function _getRewardAdviserOrRevert(address oracle, bytes4 action)\n        internal\n        view\n        returns (IRewardAdviser)\n    {\n        address adviser = rewardAdvisers[oracle][action];\n        require(adviser != address(0), \"ACM:E4\");\n        return IRewardAdviser(adviser);\n    }\n}\n"
    },
    "contracts/staking/interfaces/ITotalStaked.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @dev Interface to call `totalStaked` on the Staking contract\ninterface ITotalStaked {\n    function totalStaked() external returns (uint96);\n}\n"
    },
    "contracts/staking/mocks/MockClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"../../common/Claimable.sol\";\n\ncontract MockClaimable is Claimable {\n    function internalClaimErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        _claimErc20(token, to, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}